1. WHAT IS VUEJS?
    - Vue.js is a Javascript frameqwork used for building user interfaces and single page applications.

2. WHY VUEJS?
    - Vue.js is easy to learn and integrate with other libraries or existing projects.
    - It provides a reactive and component-based architecture, making it easier to manage and scale applications.

3. KEY FEATURES OF VUEJS
    - Reactive Data Binding: Vue.js uses a reactive data binding system that automatically updates the DOM when the underlying data changes.
    - Component-Based Architecture: Vue.js allows to create reusable components, making it easier to manage and scale applications.
    - Directives: Vue.js provides a set of built-in directives (e.g., v-if, v-for, v-bind) that simplify DOM manipulation.
    - Vue CLI: Vue.js offers a command-line interface (CLI) tool that helps scaffold and manage Vue.js projects.
    - Vue Router: Vue.js has an official router library for building single-page applications with navigation.
    - Vuex: Vue.js provides a state management library for managing application state in a centralized manner.

4. VUEJS ECOSYSTEM
    - Vue.js has a rich ecosystem of libraries and tools that enhance its functionality, including:
        - Vue Router: For handling routing in single-page applications.
        - Vuex: For state management.
        - Vue CLI: For scaffolding and managing Vue.js projects.
        - Vuetify, BootstrapVue, and Element: UI component libraries for building responsive and visually appealing applications.
        - Nuxt.js: A framework for building server-side rendered Vue.js applications.
      
5. USE OF `type=module` IN INDEX.HTML
    - The `type="module"` attribute in a script tag indicates that the script should be treated as a JavaScript module.
    - This allows the use of `import` and `export` statements within the script, enabling modular code organization and reuse.
    - When using `type="module"`, the script is executed in strict mode by default, which helps catch common coding errors and improves performance.
    - Modules are deferred by default, meaning they will not block the HTML parsing and will execute after the document has been fully parsed.
    - Example:
      ```html
      <script type="module" src="main.js"></script>
      ```
    - In this example, `main.js` can import other modules and export functionality to be used elsewhere in the application.

6. CREATEAPP
    - `createApp` is a method provided by Vue.js to create a new Vue application instance.
    - It is used to initialize the application and mount it to a specific DOM element.
    - Example:
      ```javascript
      import { createApp } from 'vue';
      import App from './App.vue';

      const app = createApp(App);
      app.mount('#app');
      ```
    - In this example, a new Vue application is created using the `App` component and mounted to the DOM element with the ID `app`.
    - The `createApp` method allows for configuring the application instance, such as adding plugins, components, and directives before mounting it to the DOM.
        - app.component('MyComponent', MyComponent);
        - app.use(MyPlugin);
        - app.directive('my-directive', MyDirective);
        - app.use(router);
        - app.use(store);
    - After configuring the application instance, the `mount` method is called to attach the Vue application to the specified DOM element, making it reactive and interactive.

7. COMPONENTS IN VUE 3
    - Components are reusable and self-contained building blocks in Vue.js that encapsulate their own structure, style and behaviour.
    - In Vue 3, components can be defined using the `defineComponent` function or as plain objects.

    WHY USE COMPONENTS?
        - Reusablity
        - Encapsulation
        - Composition - Easier to manage complex UIs by breaking them down into smaller, manageable pieces.

    TYPES OF COMPONENTS
        - Root Component: The main component that serves as the entry point of the application. `App.vue`
        - Local Component: A component that is registered and used within another component.
        - Global Component: A component that is registered globally and can be used throughout the application.
            app.component('MyComponent', MyComponent);
    
8. ASYNC COMPONENTS
    - Async components are components that are loaded asynchronously when they are needed, rather than being included in the initial bundle.
    - This can help improve the performance of the application by reducing the initial load time and allowing for code splitting.

    CREATING ASYNC COMPONENTS
        - Using defineAsyncComponent:
            ```javascript
            import { defineAsyncComponent } from 'vue';

            const AsyncComponent = defineAsyncComponent({
              loader: () => import('./MyComponent.vue'),
              loadingComponent: LoadingComponent,
              errorComponent: ErrorComponent,
              delay: 200,
              timeout: 3000
            });
            ```
9. FUNCTIONAL COMPONENTS
    - Functional components are stateless components that do not have their own instance or lifecycle methods.
    - Components without state, lifecycle hooks, or reactivity can be defined as functional components.

    // Divider.js
    import { h } from 'vue'
    export default () => h('hr', { class: 'my-divider' })

    <template>
        <div>
            <h2>Section One</h2>
            <Divider />
            <h2>Section Two</h2>
        </div>
    </template>

    <script setup>
        import Divider from './Divider.js'
    </script>

10 WAYS OF WRITING COMPONENTS

    - Option API
        - We define a component logic's using an object of options like data, methods, computed, watch, lifecycle hooks etc.
        - Properties defined by options are exposed on `this` inside functions.
        - `this` refers to the component instance.
    - Composition API
        - We define components logics using imported API functions like `ref`, `reactive`, `computed`, `watch`, `onMounted` etc.
        - In SFC's Composition API is used inside `<script setup>` block.
        - Properties defined inside `<script setup>` are directly accessible in the template without `this`.

    *NOTE* - Options API built on top of Composition API.

11. FLOW OF A VUE 3 APPLICATION
    - main.js is the entry point of the application.
    - main.js creates a Vue application instance using `createApp` and mounts it to a specific DOM element.
    - The root component (App.vue) is rendered inside the mounted DOM element.
    - createApp method accepts the root component as an argument.
    - .mount('#app') method mounts the application to the DOM element with the ID `app`.

12. USE OF `<script setup>` 

    - If we are not using `<script setup>`, we need to explicitly return the properties we want to expose to the template.

    <script>
        import { ref } from 'vue';
        export default {
            setup() {
                const message = ref('Hello World');
                return { message };
            }
        }
    </script>

    - With `<script setup>`, we don't need to return the properties, they are automatically exposed to the template.
    <script setup>
        import { ref } from 'vue';
        const message = ref('Hello World');
    </script>

13. TEMPLATE SYNTAX

    - Text Interpolation
        - {{ message }} - Interpolates the value of `message` variable.
    
    - Attribute Binding
        - v-bind:src="imageSrc" or :src="imageSrc" - Binds the `src` attribute of an image to the value of `imageSrc` variable.
        - Dynamic arguments - v-bind:[attrName]="attrValue" or :[attrName]="attrValue"
            - <div v-bind:[attrName]="attrValue"></div>
            - If attrName is "id" and attrValue is "my-div", it will render as <div id="my-div"></div>
        - Multiple attributes - v-bind="attributes"
            - <div v-bind="attributes"></div>
            - If attributes is { id: 'my-div', class: 'my-class' }, it will render as <div id="my-div" class="my-class"></div>

    - HTML Binding
        - v-html="rawHtml" - Binds the inner HTML of an element to the value of `rawHtml` variable.

    - JS Expressions
        - {{ number + 1 }} - Evaluates the expression and interpolates the result.
        - :title="`Count is ${count}`" - Evaluates the expression and binds the result to the `title` attribute.

    - Event Handling
        - v-on:click="handleClick" or @click="handleClick" - Binds the `click` event to the `handleClick` method.

14. REACTIVITY OF DATA 

    - In three ways we can bind data to the template.

        1. Without ref or reactive
            - Data is not reactive.
            - Changes to the data will not be reflected in the template.
            - Example
            <script setup>
                let count = 0
                function inc() { count++ }
            </script>

            <template>
                <p>{{ count }}</p> <!-- ❌ won't update -->
                <button @click="inc">+</button>
            </template>

        2. With ref
            - Data is reactive.
            - Used for primitive values (string, number, boolean).
            - Changes to the data will be reflected in the template.
            - Also works for objects/arrays if you want to replace the whole thing.
            - .value is used to access or modify the value of a ref.
            - Example
            <script setup>
                import { ref } from 'vue'

                const count = ref(0)
                function inc() { count.value++ }
            </script>

            <template>
                <p>{{ count }}</p> <!-- ✅ reactive -->
                <button @click="inc">+</button>
            </template>

        3. With reactive
            - Data is reactive.
            - Used for objects and arrays you want to mutate internally.
            - Wont work with primitive data types.
            - Changes to the data will be reflected in the template.
            - No need to use .value to access or modify the properties of a reactive object.
            - We can directly access or modify the properties of a reactive object.
            - If you replace the whole object/array → ❌ breaks reactivity.
            - Example
            <script setup>
                import { reactive } from 'vue'

                const state = reactive({ count: 0 })
                function inc() { state.count++ }
            </script>

            <template>
                <p>{{ state.count }}</p> <!-- ✅ updates -->
                <button @click="inc">+</button>
            </template>

15. COMPUTED PROPERTIES
    - Normally we can write simple expressions in the template.
    - For complex logic, we can use methods or computed properties.
    - Methods are re-evaluated every time the component re-renders.
    - Computed properties are cached based on their reactive dependencies.
    - Computed properties are only re-evaluated when their dependencies change.
    - Computed properties are defined using the `computed` function from Vue.
    - Example
    <script setup>
        import { ref, computed } from 'vue'
        const count = ref(0)
        const doubleCount = computed(() => count.value * 2)
        function inc() { count.value++ }
    </script>
    <template>
        <p>Count: {{ count }}</p>
        <p>Double Count: {{ doubleCount }}</p>
        <button @click="inc">+</button>
    </template>
    - Computed properties are read-only by default.
    - We can define a setter for a computed property to make it writable.
    - Example
    <script setup>
        import { ref, computed } from 'vue'
        const count = ref(0)
        const doubleCount = computed({
            get: () => count.value * 2,
            set: (val) => count.value = val / 2
        })
        function inc() { count.value++ }
    </script>
    <template>
        <p>Count: {{ count }}</p>
        <p>Double Count: {{ doubleCount }}</p>
        <button @click="inc">+</button>
        <input v-model="doubleCount" />
    </template>

16. BINDING CLASS
    - We can bind class to an element using `:class` directive.
    - We can bind class using string, object or array.
    - String
        - :class="'my-class'"
    - Object
        - :class="{ 'my-class': isActive, 'another-class': isAnotherActive }"
    - Array
        - :class="[class1, class2]"
    - Example
    <script setup>
        import { ref } from 'vue'
        const isActive = ref(true)
        const isAnotherActive = ref(false)
        const class1 = 'class-one'
        const class2 = 'class-two'
    </script>
    <template>
        <div :class="'my-class'">String Class</div>
        <div :class="{ 'my-class': isActive, 'another-class': isAnotherActive }">Object Class</div>
        <div :class="[class1, class2]">Array Class</div>
    </template>

17. BINDING STYLE
    - We can bind style to an element using `:style` directive.
    - We can bind style using object or array.
    - Object
        - :style="{ color: textColor, fontSize: fontSize + 'px' }"
    - Array
        - :style="[style1, style2]"
    - Example
    <script setup>
        import { ref } from 'vue'
        const textColor = ref('red')
        const fontSize = ref(16)
        const style1 = { color: 'blue' }
        const style2 = { fontSize: '20px' }
    </script>
    <template>
        <div :style="{ color: textColor, fontSize: fontSize + 'px' }">Object Style</div>
        <div :style="[style1, style2]">Array Style</div>
    </template>

18. WHAT HAPPENS WHEN I PASS CLASS ATTR IN CHILD COMPONENT CALL 
    - When we pass class attribut where we call the child component, the class is added to the root element of the child component.
    - If the child component has multiple root elements, it will not added to any elements, it will show the warning in the console.
    - If we want to add the class to a specific element we can use :class="$attrs.class".
    - Example
    // ParentComponent.vue
    <template>
        <ChildComponent class="my-class" />
    </template>
    <script setup>
        import ChildComponent from './ChildComponent.vue'
    </script>
    // ChildComponent.vue
    <template>
        <div class="my-class"> <!-- ❌ won't work if multiple root elements -->
            <h2>Child Component</h2>
        </div>
    </template>
    <script setup>
    </script>

19. CONDITIONAL RENDERING
    - We can conditionaly render elements by using `v-if`, `v-else-if`, `v-else` and `v-show` directives.
    - v-if
        - Renders the element only if the condition is true.
        - The element and its children and event listeners are destroyed and re-created when the condition changes.
        - We can use this in <template> or <component> tags.
        - Will not render the element if the condition is false.
    - v-else-if
        - Renders the element if the previous v-if or v-else-if condition is false and the current condition is true.
    - v-else
        - Renders the element if all previous v-if and v-else-if conditions are false.
    - v-show
        - Toggles the visibility of the element by changing its CSS `display` property.
        - The element and its children and event listeners are always present in the DOM, but hidden when the condition is false.
        - We can use this only in normal HTML tags. In <template> or <component> tags it will show a warning in the console.
        - Always renders the element, even if the condition is false.

20. LIST RENDERING
    - We can render a list of items using `v-for` directive.
    - v-for
        - Syntax: v-for="(item, index) in items" or v-for="item in items"
        - item: The current item in the iteration.
        - index: The index of the current item in the iteration (optional).
        - items: The array or object to iterate over.
        - We should provide a unique `key` attribute for each item to help Vue track changes and optimize rendering.
        - Example
        <script setup>
            import { ref } from 'vue'
            const items = ref(['Item 1', 'Item 2', 'Item 3'])
        </script>
        <template>
            <ul>
                <li v-for="(item, index) in items" :key="index">{{ item }}</li>
            </ul>
        </template>

21. IN-PLACE PATCH STRATEGY
    - If we are rendering a list without key attribute, Vue uses in-place patch strategy.
    - In-place patch strategy means Vue will try to reuse the existing DOM elements and update their content.
    - let say if we are rendering a list with li elements without key attribute - when we are updating a list it will not create new li elements, it will reuse the existing li element and just update the value inside it.
    - This can lead to unexpected behavior when the list is modified (e.g., items are added, removed, or reordered).

    ✅ Rule of Thumb for real apps:
    Always use a unique ID key (from DB, UUID, timestamp, etc.), never the array index, unless the list is 100% static.

22. EVENT HANDLING
    - We can listen to events using `v-on` directive or `@` shorthand.
    - v-on:click="handleClick" or @click="handleClick"
    - We can pass arguments to the event handler using inline statements.
        - @click="handleClick(arg1, arg2)"
    - We can use `$event` to access the native event object.
        - @click="handleClick($event)"
    - We can use event modifiers to modify the behavior of the event listener.
        - .stop - Stops the event from propagating (bubbling) up the DOM tree.
            - @click.stop="handleClick"
        - .prevent - Prevents the default action of the event.
            - @submit.prevent="handleSubmit"
        - .capture - Adds the event listener in capture mode.
            - @click.capture="handleClick"
        - .once - The event will be triggered at most once.
            - @click.once="handleClick"

23. .SELF MODIFIER
    - The .self modifier allows the event to be triggered only when the event target is the element itself, not its children.
    - Example
    <template>
        <div @click.self="handleClick" style="padding: 20px; border: 1px solid black;">
            Click me (only if you click on the box, not on the text)
            <p>Some text inside the box</p>
        </div>
    </template>
    <script setup>
        function handleClick() {
            alert('Box clicked!')
        }
    </script>
    - In this example, clicking on the div will trigger the handleClick method, but clicking on the p element inside the div will not trigger it.

24. FORM INPUT BINDING
    - We can bind form inputs using `v-model` directive.
    - v-model creates a two-way binding between the form input and the data property.
    - input (text, password, email, etc.)
        - for input fields v-model is the combination of :value and @input
            - <input v-model="text" />
            - is equivalent to
            - <input :value="text" @input="text = $event.target.value" />
    - textarea
        - for textarea v-model is the combination of :value and @input
            - <textarea v-model="message"></textarea>
    - checkbox
        - for checkbox v-model is the combination of :checked and @change
        - <input type="checkbox" v-model="isChecked" />
            - is equivalent to
            - <input type="checkbox" :checked="isChecked" @change="isChecked = $event.target.checked" />
        - We can set values for checkbox using `true-value` and `false-value` attributes.
            - <input type="checkbox" v-model="isChecked" true-value="yes" false-value="no" />
            - is equivalent to
            - <input type="checkbox" :checked="isChecked === 'yes'" @change="isChecked = $event.target.checked ? 'yes' : 'no'" />
        - for multiple checkboxes bound to an array
            - <input type="checkbox" v-model="selectedOptions" value="Option 1" />
            - <input type="checkbox" v-model="selectedOptions" value="Option 2" />
            - is equivalent to
            - <input type="checkbox" :checked="selectedOptions.includes('Option 1')" @change="updateSelectedOptions('Option 1', $event.target.checked)" />
            - <input type="checkbox" :checked="selectedOptions.includes('Option 2')" @change="updateSelectedOptions('Option 2', $event.target.checked)" />
            - function updateSelectedOptions(option, isChecked) {
                if (isChecked) {
                    selectedOptions.push(option)
                } else {
                    const index = selectedOptions.indexOf(option)
                    if (index > -1) {
                        selectedOptions.splice(index, 1)
                    }
                }
            }
    - radio
        - for radio buttons v-model is the combination of :checked and @change
            - <input type="radio" v-model="picked" value="Option 1" />
            - <input type="radio" v-model="picked" value="Option 2" />
            - is equivalent to
            - <input type="radio" :checked="picked === 'Option 1'" @change="picked = 'Option 1'" />
            - <input type="radio" :checked="picked === 'Option 2'" @change="picked = 'Option 2'" />
    - select
        - for select dropdown v-model is the combination of :value and @change
            - <select v-model="selected">
                <option value="Option 1">Option 1</option>
                <option value="Option 2">Option 2</option>
            </select>
            - is equivalent to
            - <select :value="selected" @change="selected = $event.target.value">
                <option value="Option 1">Option 1</option>
                <option value="Option 2">Option 2</option>
            </select>

25. MODIFIERS IN V-MODEL
    - We can use modifiers with v-model to modify its behavior.
    - .lazy
        - Updates the data property only when the input loses focus (on blur event).
        - <input v-model.lazy="text" />
    - .number
        - Converts the input value to a number before updating the data property.
        - <input v-model.number="age" />
    - .trim
        - Trims whitespace from the input value before updating the data property.
        - <input v-model.trim="name" />
    - Example
    <script setup>
        import { ref } from 'vue'
        const text = ref('')
        const age = ref(0)
        const name = ref('')
    </script>
    <template>
        <input v-model.lazy="text" placeholder="Lazy Input" />
        <input v-model.number="age" placeholder="Number Input" />
        <input v-model.trim="name" placeholder="Trim Input" />
        <p>Text: {{ text }}</p>
        <p>Age: {{ age }}</p>
        <p>Name: {{ name }}</p>
    </template>

26. WATCHER
    - We can watch the changes in the data properties using `watch` function from Vue.
    - It allows us to perform side effects when the watched property changes.
    - Example
    <script setup>
        import { ref, watch } from 'vue'
        const count = ref(0)
        watch(count, (newValue, oldValue) => {
            console.log(`Count changed from ${oldValue} to ${newValue}`)
        })
        function inc() { count.value++ }
    </script>
    <template>
        <p>Count: {{ count }}</p>
        <button @click="inc">+</button>
    </template>

    - It takes three arguments: source to watch, callback function and options (optional).
        - source: The data property or a function that returns the data property to watch.
        - callback: A function that is called when the watched property changes. It receives the new value and the old value as arguments.
        - options: An optional object that can contain the following properties:
            - immediate: If true, the callback is called immediately with the current value of the watched property.
            - deep: If true, the watcher will also watch for changes in nested properties of the watched object.

27. SOURCE TYPES IN WATCHER
    - We can watch different types of sources using the `watch` function.
    - Ref
        - We can watch a ref property directly.
        - Example
        const count = ref(0)
        watch(count, (newValue, oldValue) => {
            console.log(`Count changed from ${oldValue} to ${newValue}`)
        })
    - Getter Function
        - We can watch a getter function that returns a value derived from one or more reactive properties.
        - Example
        const count = ref(0)
        const doubleCount = computed(() => count.value * 2)
        watch(doubleCount, (newValue, oldValue) => {
            console.log(`Double Count changed from ${oldValue} to ${newValue}`)
        })
    - Multiple Sources
        - We can watch multiple sources by passing an array of refs or getter functions.
        - Example
        const x = ref(0)
        const y = ref(0)
        watch([x, y], ([newX, newY], [oldX, oldY]) => {
            console.log(`x changed from ${oldX} to ${newX}, y changed from ${oldY} to ${newY}`)
        })
    - Reactive Object
        - We can watch a reactive object to track changes in its properties.
        - Issue with this is we cant get previous value of the object.
        - Both newObj and oldObj will point to the same object in memory.
        - Example
        const obj = reactive({ count: 0 })
        watch(obj, (newObj, oldObj) => {
            console.log(`Obj changed from ${JSON.stringify(oldObj)} to ${JSON.stringify(newObj)}`)
        });

        - We cant directly watch object properties. We need to use getter function.
        - Example
        const obj = reactive({ count: 0 })
        watch(() => obj.count, (newCount, oldCount) => {
            console.log(`Count changed from ${oldCount} to ${newCount}`)
        })

28. DEEP AND IMMEDIATE OPTIONS IN WATCHER
    - deep
        - If true, the watcher will also watch for changes in nested properties of the watched object.
        
            const nestObj = reactive({ count: { value: 10, name: 'test' }})

            watch(nestObj, (newVal, oldVal) => {
                console.log('watch(nestObj): fired', newVal.count.value, oldVal.count.value)
            })

            // Behavior:
            //     ✅ Fires when you change nestObj.count.value
            //     ✅ Fires when you change nestObj.count.name
            //     ✅ Fires when you replace nestObj.count

            // 👉 Why? Because passing a reactive object directly makes Vue treat it as a deep watch automatically.

            watch(()=> nestObj, (newVal, oldVal) => {
                console.log('watch(() => nestObj): fired', newVal.count.value, oldVal.count.value)
            })

            // Behavior:
            //     ❌ Does not fire when you change nestObj.count.value
            //     ❌ Does not fire when you change nestObj.count.name
            //     ✅ Fires only if you replace the whole object:

            // 👉 Why? Because here you’re watching the reference to nestObj. The reference doesn’t change when you mutate its properties.

            watch(()=> nestObj, (newVal, oldVal) => {
                console.log('watch(() => nestObj, deep: true): fired', newVal.count.value, oldVal.count.value)
            }, { deep: true })

            // Behavior:
            //     ✅ Fires when you change nestObj.count.value
            //     ✅ Fires when you change nestObj.count.name
            //     ✅ Fires when you replace nestObj.count

            // 👉 Same behavior as Case 1, but here you had to explicitly tell Vue to go deep.

            // Watch a specific property - always be getter function
            watch(() => nestObj.count.value, (newVal, oldVal) => {
                console.log('watch(nestObj.count.value):', newVal, oldVal)
            })

    - immediate
        - If true, the callback is called immediately with the current value of the watched property.
        - Example
        const count = ref(0)
        watch(count, (newValue, oldValue) => {
            console.log(`Count changed from ${oldValue} to ${newValue}`)
        }, { immediate: true })

29. WATCHEFFECT && WATCHPOSTEFFECT
    - watchEffect
        - It runs the provided function immediately and tracks all reactive dependencies used inside the function.
        - Whenever any of the tracked dependencies change, the function is re-executed.
        - It does not provide access to previous values of the dependencies.
        - Example
        <script setup>
            import { ref, watchEffect } from 'vue'
            const count = ref(0)
            watchEffect(() => {
                console.log(`Count is: ${count.value}`)
            })
            function inc() { count.value++ }
        </script>
        <template>
            <p>Count: {{ count }}</p>
            <button @click="inc">+</button>
        </template>

    - watchPostEffect
        - Similar to watchEffect, but the provided function is executed after the DOM has been updated.
        - It is useful for performing side effects that depend on the updated DOM state.
        - Example
        <script setup>
            import { ref, watchPostEffect } from 'vue'
            const count = ref(0)
            watchPostEffect(() => {
                console.log(`Count is: ${count.value}`)
                // Perform DOM-related side effects here
            })
            function inc() { count.value++ }
        </script>
        <template>
            <p>Count: {{ count }}</p>
            <button @click="inc">+</button>
        </template>

    - Key Differences
        - Execution Timing: watchEffect runs immediately when defined and whenever its dependencies change, while watchPostEffect runs after the DOM has been updated.
        - Use Cases: watchEffect is suitable for general reactive side effects, while watchPostEffect is ideal for side effects that depend on the updated DOM state.
        - Dependency Tracking: Both functions automatically track reactive dependencies used within their provided functions.

    - Choosing Between Them
        - Use watchEffect when you need to react to changes in reactive data and perform side effects that do not depend on the DOM state.
        - Use watchPostEffect when your side effects require access to the updated DOM, such as manipulating DOM elements or measuring their dimensions after a change.

    - Summary
        - Both watchEffect and watchPostEffect are powerful tools for managing side effects in Vue 3 applications. 
        - The choice between them depends on whether your side effects need to interact with the DOM after it has been updated or can be executed immediately upon dependency changes.

30. LIFECYCLE HOOKS
    - Lifecyscle hooks allows us to run code at specific stages of a component's lifecycle.
    - We can have multiple lifecycle hooks of the same type in a component.

    1. onBeforeMount
        - Runs before the component is mounted to the DOM.
        - We can use this hook to perform any setup or initialization that needs to happen before the component is rendered.
        - DOM is not yet available.

    2. onMounted
        - Runs after the component is mounted to the DOM.
        - We can use this hook to perform any setup or initialization that needs to happen after the component is rendered.
        - DOM is available.
    
    3. onBeforeUnmount
        - Runs before the component is unmounted from the DOM.
        - We can use this hook to perform any cleanup or teardown that needs to happen before the component is removed from the DOM.
        - DOM is still available.

    4. onUnmounted
        - Runs after the component is unmounted from the DOM.
        - We can use this hook to perform any cleanup or teardown that needs to happen after the component is removed from the DOM.
        - DOM is not available.

    5. onBeforeUpdate
        - Runs before the component is updated.
        - DOM is still available.   

    6. onUpdated
        - Runs after the component is updated.
        - DOM is available.

31. TEMPLATE REFS
    - Template refs allows us to access DOM elements or component instances directly in the script.
    - We can create a template ref by adding the `ref` attribute to an element or component in the template.
    - We can access the ref in the script using the `ref` function from Vue.
    - Example
    <template>
        <input ref="inputRef" type="text" />
        <button @click="focusInput">Focus Input</button>
    </template>
    <script setup>
        import { ref } from 'vue'
        const inputRef = ref(null)
        function focusInput() {
            inputRef.value.focus()
        }
    </script>
    
    - Function Ref
        - <div :ref="(el) => updateRef(el)"> Another Div</div>

32. DEFINEEXPOSE
    - By default, only the props and events of a child component are accessible to the parent component.
    - If we want to expose additional properties or methods from the child component to the parent component, we can use `defineExpose`.
    - We can define the properties or methods we want to expose in an object passed to `defineExpose`.
    - Example
    // ChildComponent.vue
    <template>
        <div>Child Component</div>
    </template>
    <script setup>
        import { ref, defineExpose } from 'vue'
        const count = ref(0)
        function increment() {
            count.value++
        }
        defineExpose({
            count,
            increment
        })
    </script>

    // ParentComponent.vue
    <template>
        <ChildComponent ref="childRef" />
        <p>Count from Child: {{ childRef.count }}</p>
        <button @click="childRef.increment()">Increment Child Count</button>
    </template>
    <script setup>
        import { ref } from 'vue'
        import ChildComponent from './ChildComponent.vue'
        const childRef = ref(null)
    </script>

    - In this example, the `ChildComponent` exposes its `count` property and `increment` method using `defineExpose`. 
    - The `ParentComponent` can then access these exposed members through the `childRef` reference.

33. COMPONENTS REGISTARTION AND ITS DRAWBACKS
    - Local Registration
        - We can register a component locally within another component using the `components` option.
        - The registered component is only available within the parent component.
        - Example
        <script setup>
            import ChildComponent from './ChildComponent.vue'
        </script>
        <template>
            <ChildComponent />
        </template>
        - Drawbacks
            - We need to import and register the component in every parent component where we want to use it.
            - Can lead to repetitive code if the same component is used in multiple places.

    - Global Registration
        - We can register a component globally using the `app.component` method on the Vue application instance.
        - The registered component is available throughout the entire application without needing to import or register it in each parent component.
        - Example
        import { createApp } from 'vue'
        import App from './App.vue'
        import GlobalComponent from './GlobalComponent.vue'

        const app = createApp(App)
        app.component('GlobalComponent', GlobalComponent)
        app.mount('#app')
        - Drawbacks
            - Can lead to naming conflicts if multiple components have the same name.
            - Makes it harder to track where a component is being used, as it can be used anywhere in the application.
            - Tree-shaking may not work effectively, potentially increasing the bundle size if many global components are registered but not used.

    - Best Practices
        - Use local registration for components that are only used in a few places or are specific to a particular feature or module.
        - Use global registration for components that are widely used across the application, such as UI components (buttons, modals, etc.) or layout components (headers, footers, etc.).
        - Consider using a naming convention for globally registered components to avoid naming conflicts (e.g., prefixing with "App" or "Ui").

34. TREE-SHAKING AND CODE SPLITTING
    - Tree-shaking is a technique used to eliminate unused code from the final bundle, reducing its size and improving performance.
    - Code splitting is a technique used to split the application into smaller chunks that can be loaded on demand, improving the initial load time of the application.
    - Both techniques are important for optimizing the performance of Vue applications, especially as they grow in size and complexity.

    LOCAL REGISTRATION
        - Local registration can benefit from tree-shaking because only the components that are imported and used in a parent component are included in the final bundle.
        - If a component is not imported or used, it will be eliminated from the bundle during the tree-shaking process.

    GLOBAL REGISTRATION
        - Global registration can hinder tree-shaking because all globally registered components are included in the final bundle, regardless of whether they are used or not.
        - This can lead to larger bundle sizes and slower load times, especially if many global components are registered but not used.

    CODE SPLITTING
        - Code splitting can be achieved using dynamic imports with local registration.
        - By using dynamic imports, we can load components only when they are needed, reducing the initial load time of the application.    

35. PROPS
    - Props are used to pass data from a parent component to a child component.
    - We can define props in a child component using the `defineProps` function from Vue.
    - We can specify the type, default value, validation, and whether the prop is required or not.
    - props are reactive, meaning that if the parent component updates the prop value, the child component will automatically re-render with the new value.
    - props values are immutable in the child component, meaning that we should not modify the prop value directly in the child component.
    - If we trying to primitive value directly in the child component, it will show a warning in the console.
    - If we want to modify the prop value in the child component, we should create a local copy of the prop value using `ref` or `reactive`.
    - In case of arrays and objects, we can modify the internal properties of props , but it updates the parent component as well, which can lead to unexpected behavior.
    - Example
    const props = defineProps({
        propDetails: Object,
        changeTitle: { type: Function, default: () => {} },
        pageTitle: { type: String, default: "Blogs" },
        postId: { type: [String, Number], required: true },
        postType: { type: String, validator : (value) => ['story', 'news'].includes(value)}
    })

36. EMITS
    - Emits are used to send events from a child component to a parent component.
    - We can define emits in a child component using the `defineEmits` function from Vue.
    - We can specify the event names and their payload types.
    - We can emit events using the `emit` function returned by `defineEmits`.
    - Example
    const emit = defineEmits(['update', 'delete'])

    function updateItem(item) {
        emit('update', item)
    }

    function deleteItem(itemId) {
        emit('delete', itemId)
    }

    - We can also validate the payload of the emitted events by defining the event names and their payload types in an object.
    - Example
    const emit = defineEmits({
        update: (item) => typeof item === 'object' && item !== null,
        delete: (itemId) => typeof itemId === 'string' || typeof itemId === 'number'
    })