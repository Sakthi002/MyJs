1. WHAT IS VUEJS?
    - Vue.js is a Javascript frameqwork used for building user interfaces and single page applications.

2. WHY VUEJS?
    - Vue.js is easy to learn and integrate with other libraries or existing projects.
    - It provides a reactive and component-based architecture, making it easier to manage and scale applications.

3. KEY FEATURES OF VUEJS
    - Reactive Data Binding: Vue.js uses a reactive data binding system that automatically updates the DOM when the underlying data changes.
    - Component-Based Architecture: Vue.js allows to create reusable components, making it easier to manage and scale applications.
    - Directives: Vue.js provides a set of built-in directives (e.g., v-if, v-for, v-bind) that simplify DOM manipulation.
    - Vue CLI: Vue.js offers a command-line interface (CLI) tool that helps scaffold and manage Vue.js projects.
    - Vue Router: Vue.js has an official router library for building single-page applications with navigation.
    - Vuex: Vue.js provides a state management library for managing application state in a centralized manner.

4. VUEJS ECOSYSTEM
    - Vue.js has a rich ecosystem of libraries and tools that enhance its functionality, including:
        - Vue Router: For handling routing in single-page applications.
        - Vuex: For state management.
        - Vue CLI: For scaffolding and managing Vue.js projects.
        - Vuetify, BootstrapVue, and Element: UI component libraries for building responsive and visually appealing applications.
        - Nuxt.js: A framework for building server-side rendered Vue.js applications.
      
5. USE OF `type=module` IN INDEX.HTML
    - The `type="module"` attribute in a script tag indicates that the script should be treated as a JavaScript module.
    - This allows the use of `import` and `export` statements within the script, enabling modular code organization and reuse.
    - When using `type="module"`, the script is executed in strict mode by default, which helps catch common coding errors and improves performance.
    - Modules are deferred by default, meaning they will not block the HTML parsing and will execute after the document has been fully parsed.
    - Example:
      ```html
      <script type="module" src="main.js"></script>
      ```
    - In this example, `main.js` can import other modules and export functionality to be used elsewhere in the application.

6. CREATEAPP
    - `createApp` is a method provided by Vue.js to create a new Vue application instance.
    - It is used to initialize the application and mount it to a specific DOM element.
    - Example:
      ```javascript
      import { createApp } from 'vue';
      import App from './App.vue';

      const app = createApp(App);
      app.mount('#app');
      ```
    - In this example, a new Vue application is created using the `App` component and mounted to the DOM element with the ID `app`.
    - The `createApp` method allows for configuring the application instance, such as adding plugins, components, and directives before mounting it to the DOM.
        - app.component('MyComponent', MyComponent);
        - app.use(MyPlugin);
        - app.directive('my-directive', MyDirective);
        - app.use(router);
        - app.use(store);
    - After configuring the application instance, the `mount` method is called to attach the Vue application to the specified DOM element, making it reactive and interactive.

7. COMPONENTS IN VUE 3
    - Components are reusable and self-contained building blocks in Vue.js that encapsulate their own structure, style and behaviour.
    - In Vue 3, components can be defined using the `defineComponent` function or as plain objects.

    WHY USE COMPONENTS?
        - Reusablity
        - Encapsulation
        - Composition - Easier to manage complex UIs by breaking them down into smaller, manageable pieces.

    TYPES OF COMPONENTS
        - Root Component: The main component that serves as the entry point of the application. `App.vue`
        - Local Component: A component that is registered and used within another component.
        - Global Component: A component that is registered globally and can be used throughout the application.
            app.component('MyComponent', MyComponent);
    
8. ASYNC COMPONENTS
    - Async components are components that are loaded asynchronously when they are needed, rather than being included in the initial bundle.
    - This can help improve the performance of the application by reducing the initial load time and allowing for code splitting.

    CREATING ASYNC COMPONENTS
        - Using defineAsyncComponent:
            ```javascript
            import { defineAsyncComponent } from 'vue';

            const AsyncComponent = defineAsyncComponent({
              loader: () => import('./MyComponent.vue'),
              loadingComponent: LoadingComponent,
              errorComponent: ErrorComponent,
              delay: 200,
              timeout: 3000
            });
            ```
9. FUNCTIONAL COMPONENTS
    - Functional components are stateless components that do not have their own instance or lifecycle methods.
    - Components without state, lifecycle hooks, or reactivity can be defined as functional components.

    // Divider.js
    import { h } from 'vue'
    export default () => h('hr', { class: 'my-divider' })

    <template>
        <div>
            <h2>Section One</h2>
            <Divider />
            <h2>Section Two</h2>
        </div>
    </template>

    <script setup>
        import Divider from './Divider.js'
    </script>

10 WAYS OF WRITING COMPONENTS

    - Option API
        - We define a component logic's using an object of options like data, methods, computed, watch, lifecycle hooks etc.
        - Properties defined by options are exposed on `this` inside functions.
        - `this` refers to the component instance.
    - Composition API
        - We define components logics using imported API functions like `ref`, `reactive`, `computed`, `watch`, `onMounted` etc.
        - In SFC's Composition API is used inside `<script setup>` block.
        - Properties defined inside `<script setup>` are directly accessible in the template without `this`.

    *NOTE* - Options API built on top of Composition API.

11. FLOW OF A VUE 3 APPLICATION
    - main.js is the entry point of the application.
    - main.js creates a Vue application instance using `createApp` and mounts it to a specific DOM element.
    - The root component (App.vue) is rendered inside the mounted DOM element.
    - createApp method accepts the root component as an argument.
    - .mount('#app') method mounts the application to the DOM element with the ID `app`.

12. USE OF `<script setup>` 

    - If we are not using `<script setup>`, we need to explicitly return the properties we want to expose to the template.

    <script>
        import { ref } from 'vue';
        export default {
            setup() {
                const message = ref('Hello World');
                return { message };
            }
        }
    </script>

    - With `<script setup>`, we don't need to return the properties, they are automatically exposed to the template.
    <script setup>
        import { ref } from 'vue';
        const message = ref('Hello World');
    </script>

13. TEMPLATE SYNTAX

    - Text Interpolation
        - {{ message }} - Interpolates the value of `message` variable.
    
    - Attribute Binding
        - v-bind:src="imageSrc" or :src="imageSrc" - Binds the `src` attribute of an image to the value of `imageSrc` variable.
        - Dynamic arguments - v-bind:[attrName]="attrValue" or :[attrName]="attrValue"
            - <div v-bind:[attrName]="attrValue"></div>
            - If attrName is "id" and attrValue is "my-div", it will render as <div id="my-div"></div>
        - Multiple attributes - v-bind="attributes"
            - <div v-bind="attributes"></div>
            - If attributes is { id: 'my-div', class: 'my-class' }, it will render as <div id="my-div" class="my-class"></div>

    - HTML Binding
        - v-html="rawHtml" - Binds the inner HTML of an element to the value of `rawHtml` variable.

    - JS Expressions
        - {{ number + 1 }} - Evaluates the expression and interpolates the result.
        - :title="`Count is ${count}`" - Evaluates the expression and binds the result to the `title` attribute.

    - Event Handling
        - v-on:click="handleClick" or @click="handleClick" - Binds the `click` event to the `handleClick` method.

14. REACTIVITY OF DATA 

    - In three ways we can bind data to the template.

        1. Without ref or reactive
            - Data is not reactive.
            - Changes to the data will not be reflected in the template.
            - Example
            <script setup>
                let count = 0
                function inc() { count++ }
            </script>

            <template>
                <p>{{ count }}</p> <!-- ❌ won't update -->
                <button @click="inc">+</button>
            </template>

        2. With ref
            - Data is reactive.
            - Used for primitive values (string, number, boolean).
            - Changes to the data will be reflected in the template.
            - Also works for objects/arrays if you want to replace the whole thing.
            - .value is used to access or modify the value of a ref.
            - Example
            <script setup>
                import { ref } from 'vue'

                const count = ref(0)
                function inc() { count.value++ }
            </script>

            <template>
                <p>{{ count }}</p> <!-- ✅ reactive -->
                <button @click="inc">+</button>
            </template>

        3. With reactive
            - Data is reactive.
            - Used for objects and arrays you want to mutate internally.
            - Wont work with primitive data types.
            - Changes to the data will be reflected in the template.
            - No need to use .value to access or modify the properties of a reactive object.
            - We can directly access or modify the properties of a reactive object.
            - If you replace the whole object/array → ❌ breaks reactivity.
            - Example
            <script setup>
                import { reactive } from 'vue'

                const state = reactive({ count: 0 })
                function inc() { state.count++ }
            </script>

            <template>
                <p>{{ state.count }}</p> <!-- ✅ updates -->
                <button @click="inc">+</button>
            </template>

15. COMPUTED PROPERTIES
    - Normally we can write simple expressions in the template.
    - For complex logic, we can use methods or computed properties.
    - Methods are re-evaluated every time the component re-renders.
    - Computed properties are cached based on their reactive dependencies.
    - Computed properties are only re-evaluated when their dependencies change.
    - Computed properties are defined using the `computed` function from Vue.
    - Example
    <script setup>
        import { ref, computed } from 'vue'
        const count = ref(0)
        const doubleCount = computed(() => count.value * 2)
        function inc() { count.value++ }
    </script>
    <template>
        <p>Count: {{ count }}</p>
        <p>Double Count: {{ doubleCount }}</p>
        <button @click="inc">+</button>
    </template>
    - Computed properties are read-only by default.
    - We can define a setter for a computed property to make it writable.
    - Example
    <script setup>
        import { ref, computed } from 'vue'
        const count = ref(0)
        const doubleCount = computed({
            get: () => count.value * 2,
            set: (val) => count.value = val / 2
        })
        function inc() { count.value++ }
    </script>
    <template>
        <p>Count: {{ count }}</p>
        <p>Double Count: {{ doubleCount }}</p>
        <button @click="inc">+</button>
        <input v-model="doubleCount" />
    </template>

16. BINDING CLASS
    - We can bind class to an element using `:class` directive.
    - We can bind class using string, object or array.
    - String
        - :class="'my-class'"
    - Object
        - :class="{ 'my-class': isActive, 'another-class': isAnotherActive }"
    - Array
        - :class="[class1, class2]"
    - Example
    <script setup>
        import { ref } from 'vue'
        const isActive = ref(true)
        const isAnotherActive = ref(false)
        const class1 = 'class-one'
        const class2 = 'class-two'
    </script>
    <template>
        <div :class="'my-class'">String Class</div>
        <div :class="{ 'my-class': isActive, 'another-class': isAnotherActive }">Object Class</div>
        <div :class="[class1, class2]">Array Class</div>
    </template>

17. BINDING STYLE
    - We can bind style to an element using `:style` directive.
    - We can bind style using object or array.
    - Object
        - :style="{ color: textColor, fontSize: fontSize + 'px' }"
    - Array
        - :style="[style1, style2]"
    - Example
    <script setup>
        import { ref } from 'vue'
        const textColor = ref('red')
        const fontSize = ref(16)
        const style1 = { color: 'blue' }
        const style2 = { fontSize: '20px' }
    </script>
    <template>
        <div :style="{ color: textColor, fontSize: fontSize + 'px' }">Object Style</div>
        <div :style="[style1, style2]">Array Style</div>
    </template>

18. WHAT HAPPENS WHEN I PASS CLASS ATTR IN CHILD COMPONENT CALL 
    - When we pass class attribut where we call the child component, the class is added to the root element of the child component.
    - If the child component has multiple root elements, it will not added to any elements, it will show the warning in the console.
    - If we want to add the class to a specific element we can use :class="$attrs.class".
    - Example
    // ParentComponent.vue
    <template>
        <ChildComponent class="my-class" />
    </template>
    <script setup>
        import ChildComponent from './ChildComponent.vue'
    </script>
    // ChildComponent.vue
    <template>
        <div class="my-class"> <!-- ❌ won't work if multiple root elements -->
            <h2>Child Component</h2>
        </div>
    </template>
    <script setup>
    </script>

19. CONDITIONAL RENDERING
    - We can conditionaly render elements by using `v-if`, `v-else-if`, `v-else` and `v-show` directives.
    - v-if
        - Renders the element only if the condition is true.
        - The element and its children and event listeners are destroyed and re-created when the condition changes.
        - We can use this in <template> or <component> tags.
        - Will not render the element if the condition is false.
    - v-else-if
        - Renders the element if the previous v-if or v-else-if condition is false and the current condition is true.
    - v-else
        - Renders the element if all previous v-if and v-else-if conditions are false.
    - v-show
        - Toggles the visibility of the element by changing its CSS `display` property.
        - The element and its children and event listeners are always present in the DOM, but hidden when the condition is false.
        - We can use this only in normal HTML tags. In <template> or <component> tags it will show a warning in the console.
        - Always renders the element, even if the condition is false.

20. LIST RENDERING
    - We can render a list of items using `v-for` directive.
    - v-for
        - Syntax: v-for="(item, index) in items" or v-for="item in items"
        - item: The current item in the iteration.
        - index: The index of the current item in the iteration (optional).
        - items: The array or object to iterate over.
        - We should provide a unique `key` attribute for each item to help Vue track changes and optimize rendering.
        - Example
        <script setup>
            import { ref } from 'vue'
            const items = ref(['Item 1', 'Item 2', 'Item 3'])
        </script>
        <template>
            <ul>
                <li v-for="(item, index) in items" :key="index">{{ item }}</li>
            </ul>
        </template>

21. IN-PLACE PATCH STRATEGY
    - If we are rendering a list without key attribute, Vue uses in-place patch strategy.
    - In-place patch strategy means Vue will try to reuse the existing DOM elements and update their content.
    - let say if we are rendering a list with li elements without key attribute - when we are updating a list it will not create new li elements, it will reuse the existing li element and just update the value inside it.
    - This can lead to unexpected behavior when the list is modified (e.g., items are added, removed, or reordered).

    ✅ Rule of Thumb for real apps:
    Always use a unique ID key (from DB, UUID, timestamp, etc.), never the array index, unless the list is 100% static.

22. EVENT HANDLING
    - We can listen to events using `v-on` directive or `@` shorthand.
    - v-on:click="handleClick" or @click="handleClick"
    - We can pass arguments to the event handler using inline statements.
        - @click="handleClick(arg1, arg2)"
    - We can use `$event` to access the native event object.
        - @click="handleClick($event)"
    - We can use event modifiers to modify the behavior of the event listener.
        - .stop - Stops the event from propagating (bubbling) up the DOM tree.
            - @click.stop="handleClick"
        - .prevent - Prevents the default action of the event.
            - @submit.prevent="handleSubmit"
        - .capture - Adds the event listener in capture mode.
            - @click.capture="handleClick"
        - .once - The event will be triggered at most once.
            - @click.once="handleClick"

23. .SELF MODIFIER
    - The .self modifier allows the event to be triggered only when the event target is the element itself, not its children.
    - Example
    <template>
        <div @click.self="handleClick" style="padding: 20px; border: 1px solid black;">
            Click me (only if you click on the box, not on the text)
            <p>Some text inside the box</p>
        </div>
    </template>
    <script setup>
        function handleClick() {
            alert('Box clicked!')
        }
    </script>
    - In this example, clicking on the div will trigger the handleClick method, but clicking on the p element inside the div will not trigger it.

24. FORM INPUT BINDING
    - We can bind form inputs using `v-model` directive.
    - v-model creates a two-way binding between the form input and the data property.
    - input (text, password, email, etc.)
        - for input fields v-model is the combination of :value and @input
            - <input v-model="text" />
            - is equivalent to
            - <input :value="text" @input="text = $event.target.value" />
    - textarea
        - for textarea v-model is the combination of :value and @input
            - <textarea v-model="message"></textarea>
    - checkbox
        - for checkbox v-model is the combination of :checked and @change
        - <input type="checkbox" v-model="isChecked" />
            - is equivalent to
            - <input type="checkbox" :checked="isChecked" @change="isChecked = $event.target.checked" />
        - We can set values for checkbox using `true-value` and `false-value` attributes.
            - <input type="checkbox" v-model="isChecked" true-value="yes" false-value="no" />
            - is equivalent to
            - <input type="checkbox" :checked="isChecked === 'yes'" @change="isChecked = $event.target.checked ? 'yes' : 'no'" />
        - for multiple checkboxes bound to an array
            - <input type="checkbox" v-model="selectedOptions" value="Option 1" />
            - <input type="checkbox" v-model="selectedOptions" value="Option 2" />
            - is equivalent to
            - <input type="checkbox" :checked="selectedOptions.includes('Option 1')" @change="updateSelectedOptions('Option 1', $event.target.checked)" />
            - <input type="checkbox" :checked="selectedOptions.includes('Option 2')" @change="updateSelectedOptions('Option 2', $event.target.checked)" />
            - function updateSelectedOptions(option, isChecked) {
                if (isChecked) {
                    selectedOptions.push(option)
                } else {
                    const index = selectedOptions.indexOf(option)
                    if (index > -1) {
                        selectedOptions.splice(index, 1)
                    }
                }
            }
    - radio
        - for radio buttons v-model is the combination of :checked and @change
            - <input type="radio" v-model="picked" value="Option 1" />
            - <input type="radio" v-model="picked" value="Option 2" />
            - is equivalent to
            - <input type="radio" :checked="picked === 'Option 1'" @change="picked = 'Option 1'" />
            - <input type="radio" :checked="picked === 'Option 2'" @change="picked = 'Option 2'" />
    - select
        - for select dropdown v-model is the combination of :value and @change
            - <select v-model="selected">
                <option value="Option 1">Option 1</option>
                <option value="Option 2">Option 2</option>
            </select>
            - is equivalent to
            - <select :value="selected" @change="selected = $event.target.value">
                <option value="Option 1">Option 1</option>
                <option value="Option 2">Option 2</option>
            </select>

25. MODIFIERS IN V-MODEL
    - We can use modifiers with v-model to modify its behavior.
    - .lazy
        - Updates the data property only when the input loses focus (on blur event).
        - <input v-model.lazy="text" />
    - .number
        - Converts the input value to a number before updating the data property.
        - <input v-model.number="age" />
    - .trim
        - Trims whitespace from the input value before updating the data property.
        - <input v-model.trim="name" />
    - Example
    <script setup>
        import { ref } from 'vue'
        const text = ref('')
        const age = ref(0)
        const name = ref('')
    </script>
    <template>
        <input v-model.lazy="text" placeholder="Lazy Input" />
        <input v-model.number="age" placeholder="Number Input" />
        <input v-model.trim="name" placeholder="Trim Input" />
        <p>Text: {{ text }}</p>
        <p>Age: {{ age }}</p>
        <p>Name: {{ name }}</p>
    </template>

26. WATCHER
    - We can watch the changes in the data properties using `watch` function from Vue.
    - It allows us to perform side effects when the watched property changes.
    - Example
    <script setup>
        import { ref, watch } from 'vue'
        const count = ref(0)
        watch(count, (newValue, oldValue) => {
            console.log(`Count changed from ${oldValue} to ${newValue}`)
        })
        function inc() { count.value++ }
    </script>
    <template>
        <p>Count: {{ count }}</p>
        <button @click="inc">+</button>
    </template>

    - It takes three arguments: source to watch, callback function and options (optional).
        - source: The data property or a function that returns the data property to watch.
        - callback: A function that is called when the watched property changes. It receives the new value and the old value as arguments.
        - options: An optional object that can contain the following properties:
            - immediate: If true, the callback is called immediately with the current value of the watched property.
            - deep: If true, the watcher will also watch for changes in nested properties of the watched object.

27. SOURCE TYPES IN WATCHER
    - We can watch different types of sources using the `watch` function.
    - Ref
        - We can watch a ref property directly.
        - Example
        const count = ref(0)
        watch(count, (newValue, oldValue) => {
            console.log(`Count changed from ${oldValue} to ${newValue}`)
        })
    - Getter Function
        - We can watch a getter function that returns a value derived from one or more reactive properties.
        - Example
        const count = ref(0)
        const doubleCount = computed(() => count.value * 2)
        watch(doubleCount, (newValue, oldValue) => {
            console.log(`Double Count changed from ${oldValue} to ${newValue}`)
        })
    - Multiple Sources
        - We can watch multiple sources by passing an array of refs or getter functions.
        - Example
        const x = ref(0)
        const y = ref(0)
        watch([x, y], ([newX, newY], [oldX, oldY]) => {
            console.log(`x changed from ${oldX} to ${newX}, y changed from ${oldY} to ${newY}`)
        })
    - Reactive Object
        - We can watch a reactive object to track changes in its properties.
        - Issue with this is we cant get previous value of the object.
        - Both newObj and oldObj will point to the same object in memory.
        - Example
        const obj = reactive({ count: 0 })
        watch(obj, (newObj, oldObj) => {
            console.log(`Obj changed from ${JSON.stringify(oldObj)} to ${JSON.stringify(newObj)}`)
        });

        - We cant directly watch object properties. We need to use getter function.
        - Example
        const obj = reactive({ count: 0 })
        watch(() => obj.count, (newCount, oldCount) => {
            console.log(`Count changed from ${oldCount} to ${newCount}`)
        })

28. DEEP AND IMMEDIATE OPTIONS IN WATCHER
    - deep
        - If true, the watcher will also watch for changes in nested properties of the watched object.
        
            const nestObj = reactive({ count: { value: 10, name: 'test' }})

            watch(nestObj, (newVal, oldVal) => {
                console.log('watch(nestObj): fired', newVal.count.value, oldVal.count.value)
            })

            // Behavior:
            //     ✅ Fires when you change nestObj.count.value
            //     ✅ Fires when you change nestObj.count.name
            //     ✅ Fires when you replace nestObj.count

            // 👉 Why? Because passing a reactive object directly makes Vue treat it as a deep watch automatically.

            watch(()=> nestObj, (newVal, oldVal) => {
                console.log('watch(() => nestObj): fired', newVal.count.value, oldVal.count.value)
            })

            // Behavior:
            //     ❌ Does not fire when you change nestObj.count.value
            //     ❌ Does not fire when you change nestObj.count.name
            //     ✅ Fires only if you replace the whole object:

            // 👉 Why? Because here you’re watching the reference to nestObj. The reference doesn’t change when you mutate its properties.

            watch(()=> nestObj, (newVal, oldVal) => {
                console.log('watch(() => nestObj, deep: true): fired', newVal.count.value, oldVal.count.value)
            }, { deep: true })

            // Behavior:
            //     ✅ Fires when you change nestObj.count.value
            //     ✅ Fires when you change nestObj.count.name
            //     ✅ Fires when you replace nestObj.count

            // 👉 Same behavior as Case 1, but here you had to explicitly tell Vue to go deep.

            // Watch a specific property - always be getter function
            watch(() => nestObj.count.value, (newVal, oldVal) => {
                console.log('watch(nestObj.count.value):', newVal, oldVal)
            })

    - immediate
        - If true, the callback is called immediately with the current value of the watched property.
        - Example
        const count = ref(0)
        watch(count, (newValue, oldValue) => {
            console.log(`Count changed from ${oldValue} to ${newValue}`)
        }, { immediate: true })

29. WATCHEFFECT && WATCHPOSTEFFECT
    - watchEffect
        - It runs the provided function immediately and tracks all reactive dependencies used inside the function.
        - Whenever any of the tracked dependencies change, the function is re-executed.
        - It does not provide access to previous values of the dependencies.
        - Example
        <script setup>
            import { ref, watchEffect } from 'vue'
            const count = ref(0)
            watchEffect(() => {
                console.log(`Count is: ${count.value}`)
            })
            function inc() { count.value++ }
        </script>
        <template>
            <p>Count: {{ count }}</p>
            <button @click="inc">+</button>
        </template>

    - watchPostEffect
        - Similar to watchEffect, but the provided function is executed after the DOM has been updated.
        - It is useful for performing side effects that depend on the updated DOM state.
        - Example
        <script setup>
            import { ref, watchPostEffect } from 'vue'
            const count = ref(0)
            watchPostEffect(() => {
                console.log(`Count is: ${count.value}`)
                // Perform DOM-related side effects here
            })
            function inc() { count.value++ }
        </script>
        <template>
            <p>Count: {{ count }}</p>
            <button @click="inc">+</button>
        </template>

    - Key Differences
        - Execution Timing: watchEffect runs immediately when defined and whenever its dependencies change, while watchPostEffect runs after the DOM has been updated.
        - Use Cases: watchEffect is suitable for general reactive side effects, while watchPostEffect is ideal for side effects that depend on the updated DOM state.
        - Dependency Tracking: Both functions automatically track reactive dependencies used within their provided functions.

    - Choosing Between Them
        - Use watchEffect when you need to react to changes in reactive data and perform side effects that do not depend on the DOM state.
        - Use watchPostEffect when your side effects require access to the updated DOM, such as manipulating DOM elements or measuring their dimensions after a change.

    - Summary
        - Both watchEffect and watchPostEffect are powerful tools for managing side effects in Vue 3 applications. 
        - The choice between them depends on whether your side effects need to interact with the DOM after it has been updated or can be executed immediately upon dependency changes.

30. LIFECYCLE HOOKS
    - Lifecyscle hooks allows us to run code at specific stages of a component's lifecycle.
    - We can have multiple lifecycle hooks of the same type in a component.

    1. onBeforeMount
        - Runs before the component is mounted to the DOM.
        - We can use this hook to perform any setup or initialization that needs to happen before the component is rendered.
        - DOM is not yet available.

    2. onMounted
        - Runs after the component is mounted to the DOM.
        - We can use this hook to perform any setup or initialization that needs to happen after the component is rendered.
        - DOM is available.
    
    3. onBeforeUnmount
        - Runs before the component is unmounted from the DOM.
        - We can use this hook to perform any cleanup or teardown that needs to happen before the component is removed from the DOM.
        - DOM is still available.

    4. onUnmounted
        - Runs after the component is unmounted from the DOM.
        - We can use this hook to perform any cleanup or teardown that needs to happen after the component is removed from the DOM.
        - DOM is not available.

    5. onBeforeUpdate
        - Runs before the component is updated.
        - DOM is still available.   

    6. onUpdated
        - Runs after the component is updated.
        - DOM is available.

31. TEMPLATE REFS
    - Template refs allows us to access DOM elements or component instances directly in the script.
    - We can create a template ref by adding the `ref` attribute to an element or component in the template.
    - We can access the ref in the script using the `ref` function from Vue.
    - Example
    <template>
        <input ref="inputRef" type="text" />
        <button @click="focusInput">Focus Input</button>
    </template>
    <script setup>
        import { ref } from 'vue'
        const inputRef = ref(null)
        function focusInput() {
            inputRef.value.focus()
        }
    </script>
    
    - Function Ref
        - <div :ref="(el) => updateRef(el)"> Another Div</div>

32. DEFINEEXPOSE
    - By default, only the props and events of a child component are accessible to the parent component.
    - If we want to expose additional properties or methods from the child component to the parent component, we can use `defineExpose`.
    - We can define the properties or methods we want to expose in an object passed to `defineExpose`.
    - Example
    // ChildComponent.vue
    <template>
        <div>Child Component</div>
    </template>
    <script setup>
        import { ref, defineExpose } from 'vue'
        const count = ref(0)
        function increment() {
            count.value++
        }
        defineExpose({
            count,
            increment
        })
    </script>

    // ParentComponent.vue
    <template>
        <ChildComponent ref="childRef" />
        <p>Count from Child: {{ childRef.count }}</p>
        <button @click="childRef.increment()">Increment Child Count</button>
    </template>
    <script setup>
        import { ref } from 'vue'
        import ChildComponent from './ChildComponent.vue'
        const childRef = ref(null)
    </script>

    - In this example, the `ChildComponent` exposes its `count` property and `increment` method using `defineExpose`. 
    - The `ParentComponent` can then access these exposed members through the `childRef` reference.

33. COMPONENTS REGISTARTION AND ITS DRAWBACKS
    - Local Registration
        - We can register a component locally within another component using the `components` option.
        - The registered component is only available within the parent component.
        - Example
        <script setup>
            import ChildComponent from './ChildComponent.vue'
        </script>
        <template>
            <ChildComponent />
        </template>
        - Drawbacks
            - We need to import and register the component in every parent component where we want to use it.
            - Can lead to repetitive code if the same component is used in multiple places.

    - Global Registration
        - We can register a component globally using the `app.component` method on the Vue application instance.
        - The registered component is available throughout the entire application without needing to import or register it in each parent component.
        - Example
        import { createApp } from 'vue'
        import App from './App.vue'
        import GlobalComponent from './GlobalComponent.vue'

        const app = createApp(App)
        app.component('GlobalComponent', GlobalComponent)
        app.mount('#app')
        - Drawbacks
            - Can lead to naming conflicts if multiple components have the same name.
            - Makes it harder to track where a component is being used, as it can be used anywhere in the application.
            - Tree-shaking may not work effectively, potentially increasing the bundle size if many global components are registered but not used.

    - Best Practices
        - Use local registration for components that are only used in a few places or are specific to a particular feature or module.
        - Use global registration for components that are widely used across the application, such as UI components (buttons, modals, etc.) or layout components (headers, footers, etc.).
        - Consider using a naming convention for globally registered components to avoid naming conflicts (e.g., prefixing with "App" or "Ui").

34. TREE-SHAKING AND CODE SPLITTING
    - Tree-shaking is a technique used to eliminate unused code from the final bundle, reducing its size and improving performance.
    - Code splitting is a technique used to split the application into smaller chunks that can be loaded on demand, improving the initial load time of the application.
    - Both techniques are important for optimizing the performance of Vue applications, especially as they grow in size and complexity.

    LOCAL REGISTRATION
        - Local registration can benefit from tree-shaking because only the components that are imported and used in a parent component are included in the final bundle.
        - If a component is not imported or used, it will be eliminated from the bundle during the tree-shaking process.

    GLOBAL REGISTRATION
        - Global registration can hinder tree-shaking because all globally registered components are included in the final bundle, regardless of whether they are used or not.
        - This can lead to larger bundle sizes and slower load times, especially if many global components are registered but not used.

    CODE SPLITTING
        - Code splitting can be achieved using dynamic imports with local registration.
        - By using dynamic imports, we can load components only when they are needed, reducing the initial load time of the application.    

35. PROPS
    - Props are used to pass data from a parent component to a child component.
    - We can define props in a child component using the `defineProps` function from Vue.
    - We can specify the type, default value, validation, and whether the prop is required or not.
    - props are reactive, meaning that if the parent component updates the prop value, the child component will automatically re-render with the new value.
    - props values are immutable in the child component, meaning that we should not modify the prop value directly in the child component.
    - If we trying to primitive value directly in the child component, it will show a warning in the console.
    - If we want to modify the prop value in the child component, we should create a local copy of the prop value using `ref` or `reactive`.
    - In case of arrays and objects, we can modify the internal properties of props , but it updates the parent component as well, which can lead to unexpected behavior.
    - Example
    const props = defineProps({
        propDetails: Object,
        changeTitle: { type: Function, default: () => {} },
        pageTitle: { type: String, default: "Blogs" },
        postId: { type: [String, Number], required: true },
        postType: { type: String, validator : (value) => ['story', 'news'].includes(value)}
    })

36. EMITS
    - Emits are used to send events from a child component to a parent component.
    - We can define emits in a child component using the `defineEmits` function from Vue.
    - We can specify the event names and their payload types.
    - We can emit events using the `emit` function returned by `defineEmits`.
    - Example
    const emit = defineEmits(['update', 'delete'])

    function updateItem(item) {
        emit('update', item)
    }

    function deleteItem(itemId) {
        emit('delete', itemId)
    }

    - We can also validate the payload of the emitted events by defining the event names and their payload types in an object.
    - Example
    const emit = defineEmits({
        update: (item) => typeof item === 'object' && item !== null,
        delete: (itemId) => typeof itemId === 'string' || typeof itemId === 'number'
    })

37. V-MODEL ON COMPONENTS
    - We can use `v-model` directive on custom components to create a two-way binding between a parent component and a child component.
    - By default, `v-model` uses the `modelValue` prop and the `update:modelValue` event for binding.
    - In the child component, we need to define the `modelValue` prop using `defineProps` and emit the `update:modelValue` event using `defineEmits`.
    - Example
    // ChildComponent.vue
        <template>
            <input :value="modelValue" @input="updateValue($event.target.value)" />
        </template>
        <script setup>
            const props = defineProps({
                modelValue: String
            })
            const emit = defineEmits(['update:modelValue'])
            function updateValue(value) {
                emit('update:modelValue', value)
            }
        </script>

        // ParentComponent.vue
        <template>
            <ChildComponent v-model="text" />
            <p>Text: {{ text }}</p>
        </template>

    - We can bind multiple `v-model` directives to a single component by using different prop and event names.
    - We can customize the prop and event names used by `v-model` by using the `model` option in the child component.
    - Example
    // ChildComponent.vue
        <template>  
            <input :value="title" @input="updateTitle($event.target.value)" />
            <textarea :value="content" @input="updateContent($event.target.value)"></textarea>
        </template>
        <script setup>
            const props = defineProps({
                title: String,
                content: String
            })
            const emit = defineEmits(['update:title', 'update:content'])
            function updateTitle(value) {
                emit('update:title', value)
            }
            function updateContent(value) {
                emit('update:content', value)
            }
        </script>
        // ParentComponent.vue
        <template>
            <ChildComponent v-model:title="postTitle" v-model:content="postContent" />
            <p>Title: {{ postTitle }}</p>
            <p>Content: {{ postContent }}</p>
        </template>
        <script setup>
            import { ref } from 'vue'
            const postTitle = ref('')
            const postContent = ref('')
        </script>

38. CUSTOM MODIFIERS IN V-MODEL
    - We can create custom modifiers for `v-model` by defining a custom prop and event names in the child component.
    - We can then use these custom prop and event names in the parent component with `v-model`.
    - Vue’s v-model modifiers (.capitalize, .debounce, etc.) only work when a component is being used by a parent.
    - Inside the same component, Vue doesn’t inject modelModifiers automatically (because there’s no parent binding).
    - Example
    // ChildComponent.vue
        <script setup>
            const props = defineProps({
                title: { type: String, default: '' },
                titleModifiers: { type: Object, default: () => {}}
            })
            const emit = defineEmits(['update:title']);
            const update = (e) => {
                let value = e.target.value;
                if(props.titleModifiers['no-hyphens']) {
                    value = value.split("-").join("");
                }
                emit('update:title', value)
            }
        </script>
        <template>
            <h1>Custom Input</h1>
            <div>
                <input type="text" name="title" id="title" :value="title" @input="update">
            </div>
        </template>
    // ParentComponent.vue
        <script setup>
            import { ref } from 'vue'
            import ChildComponent from './ChildComponent.vue'
            const title = ref('');
        </script>
        <template>
            <ChildComponent v-model:title.no-hyphens="title"/>
            {{ title }}
        </template>

39. FALLTHROUGH ATTRIBUTES - ATTRIBUTES INHERITANCE
    - If we are passing any attributes (class, id, style, events) to child component, if those are not defined as props or emits in the child component, 
        those attributes will be added to the root element of the child component.
    - This is known as "fallthrough attributes" or "attributes inheritance".
    - It will merge the attributes with the root element of the child component. if same attribute is defined in both parent and child component, the value from the parent component will take precedence.
    - click events will also be merged, both parent and child click events will be triggered.
    - For nested components, the fallthrough attributes will be added to the root element of the outermost child component.
    - Example
    // ChildComponent.vue
        <template>
            <div>Child Component</div>
        </template>
        <script setup>
        </script>
    // ParentComponent.vue
        <template>
            <ChildComponent class="my-class" id="my-id" data-info="some-data" />
        </template>
        <script setup>
            import ChildComponent from './ChildComponent.vue'
        </script>
    - In this example, the `class`, `id`, and `data-info` attributes will be added to the root `<div>` element of the `ChildComponent`.

    - If the child component has multiple root elements, fallthrough attributes will not be added to any elements, and a warning will be shown in the console.
    - If we want to add the attributes to a specific element in the child component, we can use `v-bind="$attrs"` on that element.
    - Example
    // ChildComponent.vue
        <template>
            <div v-bind="$attrs">Child Component</div>
            <p>Another Element</p>
        </template>
        <script setup>
        </script>
    - In this example, the fallthrough attributes will be added to the `<div>` element, but not to the `<p>` element.

40. DISABLE ATTRIBUTES INHERITANCE
    - In vue 3 we can disable fallthrough attributes by setting `inheritAttrs` to false in the child component.
    - Example
    // ChildComponent.vue
        <template>
            <div>Child Component</div>
        </template>
        <script setup>
            defineOptions({ inheritAttrs: false })
        </script>
    - In this example, the fallthrough attributes will not be added to any elements in the `ChildComponent`.

41. USEATTRS
    - We can access the fallthrough attributes in the child component using the `useAttrs` function from Vue.
    - `useAttrs` returns a reactive object containing all the fallthrough attributes passed to the component.
    - Example
        <script setup>
            import { useAttrs } from 'vue'
            const attrs = useAttrs()
        </script>

42. SLOTS | NAMED SLOTS | SCOPED SLOTS
    - Slots are used to pass content from a parent component to a child component.
    - We can define slots in a child component using the `<slot>` element in the template.
    - We can pass content to the slots in the parent component by placing the content between the opening and closing tags of the child component.
    - Default Slot
        - If we define a slot without a name, it is considered as the default slot.
        - Example
        // ChildComponent.vue
            <template>
                <div>
                    <h2>Child Component</h2>
                    <slot></slot>
                </div>
            </template>
            <script setup>
            </script>
        // ParentComponent.vue
            <template>
                <ChildComponent>
                    <p>This is some content for the default slot.</p>
                </ChildComponent>
            </template>
            <script setup>
                import ChildComponent from './ChildComponent.vue'
            </script>

    - Named Slots
        - We can define multiple named slots in a child component by adding the `name` attribute to the `<slot>` element.
        - We can pass content to named slots in the parent component by using the `v-slot` directive or the shorthand `#` syntax.
        - Example
        // ChildComponent.vue
            <template>
                <div>
                    <h2>Child Component</h2>
                    <slot name="header"></slot>
                    <slot></slot> <!-- Default Slot -->
                    <slot name="footer"></slot>
                </div>
            </template>
            <script setup>
            </script>
        // ParentComponent.vue
            <template>
                <ChildComponent>
                    <template #header>
                        <h3>This is the header slot content.</h3>
                    </template>

                    <p>This is some content for the default slot.</p>

                    <template v-slot:footer>
                        <p>This is the footer slot content.</p>
                    </template>
                </ChildComponent>
            </template>
            <script setup>
                import ChildComponent from './ChildComponent.vue'
            </script>

    - Scoped Slots
        - Scoped slots allow us to pass data from a child component to a parent component through slots.
        - We can define scoped slots in a child component by adding a `v-slot` directive with a scope variable to the `<slot>` element.
        - We can access the scoped data in the parent component by using the scope variable in the `v-slot` directive or the shorthand `#` syntax.
        - Example
        // ChildComponent.vue
            <template>
                <div>
                    <h2>Child Component</h2>
                    <slot :message="message"></slot>
                </div>
            </template>
            <script setup>
                import { ref } from 'vue'
                const message = ref('Hello from Child Component!')
            </script>
        // ParentComponent.vue
            <template>
                <ChildComponent>
                    <template #default="{ message }">
                        <p>{{ message }}</p>
                    </template>
                </ChildComponent>
            </template>
            <script setup>
                import ChildComponent from './ChildComponent.vue'
            </script>
    - In this example, the `ChildComponent` defines a scoped slot that passes a `message` variable to the parent component. 

43. PROP DRILLING
    - Prop drilling is the process of passing data from a parent component to a child component through multiple levels of nested components.
    - It can lead to code that is hard to maintain and understand, especially when the data needs to be passed through many levels of components.
    - To avoid prop drilling, we can use state management libraries like Vuex or Pinia, or we can use the provide/inject API in Vue.
    - Example of prop drilling
    // GrandParentComponent.vue
        <template>
            <ParentComponent :data="data" />
        </template>
        <script setup>
            import { ref } from 'vue'
            import ParentComponent from './ParentComponent.vue'
            const data = ref('Some data')
        </script>
    // ParentComponent.vue
        <template>
            <ChildComponent :data="data" />
        </template>
        <script setup>
            import ChildComponent from './ChildComponent.vue'
            const props = defineProps({
                data: String
            })
        </script>
    // ChildComponent.vue
        <template>
            <p>{{ data }}</p>
        </template>
        <script setup>
            const props = defineProps({
                data: String
            })
        </script>

44. PROVIDE / INJECT
    - The provide/inject API allows us to share data between a parent component and its descendants without having to pass the data through multiple levels of components.
    - We can use the `provide` function in the parent component to provide data to its descendants.
    - We can use the `inject` function in the descendant components to access the provided data.
    - We can provide any type of data, including primitive values, objects, and functions.
    - The provided data is reactive, meaning that if the parent component updates the provided data, the descendant components will automatically re-render with the new value.
    - The provided data is not limited to direct children; it can be accessed by any descendant component in the component tree.
    - We can provide data from app level using `app.provide` method, and we can inject that data in any component in the application.
    - Example
    // ParentComponent.vue
        <template>
            <ChildComponent />
        </template>
        <script setup>
            import { provide } from 'vue'
            import ChildComponent from './ChildComponent.vue'
            const data = 'Some data'
            provide('data', data)
        </script>
    // ChildComponent.vue
        <template>
            <GrandChildComponent />
        </template>
        <script setup>
            import GrandChildComponent from './GrandChildComponent.vue'
        </script>
    // GrandChildComponent.vue
        <template>
            <p>{{ data }}</p>
        </template>
        <script setup>
            import { inject } from 'vue'
            const data = inject('data')
        </script>

45. DEFINEASYNCCOMPONENT
    - We can define async components using the `defineAsyncComponent` function from Vue.
    - It allows us to load components lazily, which can improve the initial load time of the application.
    - We can provide a factory function that returns a promise that resolves to the component definition.
    - We can also provide options for loading and error states, as well as a timeout for loading the component.
    - Example
    <script setup>
        import { defineAsyncComponent } from 'vue'
        const AsyncComponent = defineAsyncComponent(() => import('./AsyncComponent.vue'))
        const AsyncTodoComponent = defineAsyncComponent({
            loader: () => {
                return new Promise(function (resolve, reject) {
                    setTimeout(() => {
                        resolve(import ('./TodoList.vue'))
                    }, 3000);
                })
            },
            loadingComponent: Loader,
            errorComponent: Error
        })
    </script>
    <template>
        <AsyncComponent />
        <AsyncTodoComponent />
    </template>

46. COMPOSABLES
    - Composables are reusable functions that encapsulate logic and state, allowing us to share functionality across multiple components.
    - We can create composables by defining a function that uses Vue's reactivity system (e.g., `ref`, `reactive`, `computed`, `watch`, etc.) and returns the reactive state and methods.
    - We can then import and use the composable function in any component where we need the shared functionality.
    - Composables help to keep our components clean and focused on their specific responsibilities, while also promoting code reuse and maintainability.
    - Example
    // useCounter.js
        import { ref } from 'vue'
        export function useCounter() {
            const count = ref(0)
            function increment() {
                count.value++
            }
            function decrement() {
                count.value--
            }
            return {
                count,
                increment,
                decrement
            }
        }
    // CounterComponent.vue
        <template>
            <p>Count: {{ count }}</p>
            <button @click="decrement">-</button>
            <button @click="increment">+</button>
        </template>
        <script setup>
            import { useCounter } from './useCounter.js'
            const { count, increment, decrement } = useCounter()
        </script>
    
    - We can also create composables that accept parameters to customize their behavior.
    - Example
    // useFetch.js
        import { ref } from 'vue'
        export function useFetch(url) {
            const data = ref(null)
            const error = ref(null)
            const loading = ref(false)
            async function fetchData() {
                loading.value = true
                try {
                    const response = await fetch(url)
                    data.value = await response.json()
                } catch (err) {
                    error.value = err
                } finally {
                    loading.value = false
                }
            }
            return {
                data,
                error,
                loading,
                fetchData
            }
        }
    // FetchComponent.vue
        <template>
            <div v-if="loading">Loading...</div>
            <div v-else-if="error">Error: {{ error.message }}</div>
            <div v-else-if="data">{{ data }}</div>
            <button @click="fetchData">Fetch Data</button>
        </template>
        <script setup>
            import { useFetch } from './useFetch.js'
            const { data, error, loading, fetchData } = useFetch('https://api.example.com/data')
        </script>   
    













// SUSPENSE

//////// COMMON ISSUES AND BEST PRACTICES
    - MUTATING PROPS
        - Props are meant to be immutable in the child component. 
        - If we need to modify a prop value, we should create a local copy using `ref` or `reactive`.
        - Example
        const props = defineProps({
            initialCount: { type: Number, required: true }
        })
        const count = ref(props.initialCount) // Create a local copy
        function increment() {
            count.value++
        }
    - KEY ATTRIBUTE IN LIST RENDERING
        - When rendering lists using `v-for`, we should always provide a unique `key` attribute to each item.
        - This helps Vue to efficiently update the DOM when the list changes.
        - Example
        <div v-for="item in items" :key="item.id">
            {{ item.name }}
        </div>
    - AVOIDING SIDE EFFECTS IN COMPUTED PROPERTIES
        - Computed properties should be pure functions that only depend on reactive data.
        - We should avoid performing side effects (like API calls or DOM manipulations) inside computed properties.
        - If we need to perform side effects, we should use watchers or lifecycle hooks instead.
    - USING WATCHERS JUDICIOUSLY
        - While watchers are powerful, we should use them judiciously.
        - Overusing watchers can lead to complex and hard-to-maintain code.
        - We should prefer computed properties for deriving values from reactive data whenever possible.
    - CLEANING UP SIDE EFFECTS
        - When using watchers or lifecycle hooks to perform side effects, we should ensure that we clean up any resources (like event listeners or timers) when the component is unmounted.
        - We can do this in the `onBeforeUnmount` or `onUnmounted` lifecycle hooks.
    - PERFORMANCE OPTIMIZATIONS
        - We should be mindful of performance when working with large datasets or complex components.
        - Techniques like lazy loading, code splitting, and optimizing reactivity can help improve performance.
    - DEBUGGING TOOLS
        - We can use Vue Devtools to inspect the component hierarchy, state, and events in our Vue applications.
        - This can help us identify and fix issues more easily.
    - COMMON PITFALLS
        - Be aware of common pitfalls like infinite loops in watchers, incorrect usage of `this` in composition API, and misunderstanding of reactivity principles.
        - Always refer to the official Vue documentation for best practices and guidelines.

/////// ACCESSABILITY
    - ACCESSABILITY is important for making our applications usable by people with disabilities.
    - We should follow best practices for accessibility, such as using semantic HTML, providing alternative text for images, and ensuring that our applications are navigable using a keyboard.
    - We can use tools like axe or Lighthouse to audit the accessibility of our applications and identify areas for improvement.
    - We should also consider accessibility when designing our components and user interfaces.
    - Vue provides some built-in directives and components to help with accessibility, such as `v-focus` and `aria-*` attributes.
    - We should also be mindful of color contrast and font sizes to ensure that our applications are readable by all users.
    - Testing with screen readers and other assistive technologies can help us identify accessibility issues and improve the user experience for all users.

/////// COMMON WARNINGS AND ERRORS
    - REACTIVE WARNINGS
        - Avoid mutating props directly in child components. Create local copies instead.
        - Ensure that reactive data is properly initialized to avoid undefined or null values.
        - Use unique keys in `v-for` loops to help Vue track elements efficiently.
    - PERFORMANCE WARNINGS
        - Be cautious with deep watchers as they can lead to performance issues. Use them only when necessary.
        - Avoid unnecessary re-renders by using computed properties instead of methods in templates.
        - Limit the number of reactive dependencies in computed properties to improve performance.
    - DEPLOYMENT WARNINGS
        - Ensure that the production build is optimized by using tools like Webpack or Vite.
        - Check for unused dependencies and remove them to reduce bundle size.
        - Verify that environment variables are correctly set for different deployment environments.
    - COMMON ERRORS
        - Ensure that all required props are passed to child components to avoid runtime errors.
        - Handle asynchronous operations properly to avoid unhandled promise rejections.
        - Use try-catch blocks around code that may throw errors, especially in lifecycle hooks and watchers.
        - Validate data types of props and emitted events to prevent type-related errors.
    - DEBUGGING TIPS
        - Use Vue Devtools to inspect component state, props, and events.
        - Check the console for warnings and errors during development.
        - Write unit tests for components to catch issues early in the development process.
    - COMMON WARNINGS
        - MUTATING A PROP DIRECTLY
        - NON-UNIQUE KEYS IN V-FOR
        - MISSING KEY ATTRIBUTE
        - UNHANDLED PROMISE REJECTION
        - DEPENDENCY CYCLE DETECTED
        - INVALID EVENT HANDLER
        - AVOID USING V-IF WITH V-FOR ON THE SAME ELEMENT
        - USING V-HTML CAN LEAD TO XSS VULNERABILITIES
        - WATCHER CALLBACKS SHOULD NOT MODIFY THE WATCHED SOURCE
        - COMPUTED PROPERTIES SHOULD NOT HAVE SIDE EFFECTS
        - AVOID USING INDEX AS KEY IN V-FOR
        - ENSURE ALL REQUIRED PROPS ARE PROVIDED
        - AVOID DEEP WATCHERS UNLESS NECESSARY
        - AVOID COMPLEX EXPRESSIONS IN TEMPLATES
        - USE VUE DEVTOOLS FOR DEBUGGING
        - CHECK FOR UNUSED VARIABLES OR IMPORTS
        - ENSURE PROPER CLEANUP IN LIFECYCLE HOOKS
        - AVOID MUTATING REACTIVE DATA OUTSIDE OF REACTIVE CONTEXTS
        - USE TRY-CATCH FOR ASYNC OPERATIONS
        - VALIDATE PROP TYPES AND EVENT PAYLOADS
        - OPTIMIZE PERFORMANCE WITH COMPUTED PROPERTIES
        - ENSURE PRODUCTION BUILD IS OPTIMIZED
        - CHECK FOR ACCESSIBILITY ISSUES
        - TEST WITH SCREEN READERS AND ASSISTIVE TECHNOLOGIES
        - FOLLOW BEST PRACTICES FOR ACCESSIBILITY




























    // HYDRATION WARNINGS

    // SSR

    // WEB ACCESSABILITY