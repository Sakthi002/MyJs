1. WHAT IS VUEJS?
    - Vue.js is a Javascript frameqwork used for building user interfaces and single page applications.

2. WHY VUEJS?
    - Vue.js is easy to learn and integrate with other libraries or existing projects.
    - It provides a reactive and component-based architecture, making it easier to manage and scale applications.

3. KEY FEATURES OF VUEJS
    - Reactive Data Binding: Vue.js uses a reactive data binding system that automatically updates the DOM when the underlying data changes.
    - Component-Based Architecture: Vue.js allows to create reusable components, making it easier to manage and scale applications.
    - Directives: Vue.js provides a set of built-in directives (e.g., v-if, v-for, v-bind) that simplify DOM manipulation.
    - Vue CLI: Vue.js offers a command-line interface (CLI) tool that helps scaffold and manage Vue.js projects.
    - Vue Router: Vue.js has an official router library for building single-page applications with navigation.
    - Vuex: Vue.js provides a state management library for managing application state in a centralized manner.

4. VUEJS ECOSYSTEM
    - Vue.js has a rich ecosystem of libraries and tools that enhance its functionality, including:
        - Vue Router: For handling routing in single-page applications.
        - Vuex: For state management.
        - Vue CLI: For scaffolding and managing Vue.js projects.
        - Vuetify, BootstrapVue, and Element: UI component libraries for building responsive and visually appealing applications.
        - Nuxt.js: A framework for building server-side rendered Vue.js applications.
      
5. USE OF `type=module` IN INDEX.HTML
    - The `type="module"` attribute in a script tag indicates that the script should be treated as a JavaScript module.
    - This allows the use of `import` and `export` statements within the script, enabling modular code organization and reuse.
    - When using `type="module"`, the script is executed in strict mode by default, which helps catch common coding errors and improves performance.
    - Modules are deferred by default, meaning they will not block the HTML parsing and will execute after the document has been fully parsed.
    - Example:
      ```html
      <script type="module" src="main.js"></script>
      ```
    - In this example, `main.js` can import other modules and export functionality to be used elsewhere in the application.

6. CREATEAPP
    - `createApp` is a method provided by Vue.js to create a new Vue application instance.
    - It is used to initialize the application and mount it to a specific DOM element.
    - Example:
      ```javascript
      import { createApp } from 'vue';
      import App from './App.vue';

      const app = createApp(App);
      app.mount('#app');
      ```
    - In this example, a new Vue application is created using the `App` component and mounted to the DOM element with the ID `app`.
    - The `createApp` method allows for configuring the application instance, such as adding plugins, components, and directives before mounting it to the DOM.
        - app.component('MyComponent', MyComponent);
        - app.use(MyPlugin);
        - app.directive('my-directive', MyDirective);
        - app.use(router);
        - app.use(store);
    - After configuring the application instance, the `mount` method is called to attach the Vue application to the specified DOM element, making it reactive and interactive.

7. COMPONENTS IN VUE 3
    - Components are reusable and self-contained building blocks in Vue.js that encapsulate their own structure, style and behaviour.
    - In Vue 3, components can be defined using the `defineComponent` function or as plain objects.

    WHY USE COMPONENTS?
        - Reusablity
        - Encapsulation
        - Composition - Easier to manage complex UIs by breaking them down into smaller, manageable pieces.

    TYPES OF COMPONENTS
        - Root Component: The main component that serves as the entry point of the application. `App.vue`
        - Local Component: A component that is registered and used within another component.
        - Global Component: A component that is registered globally and can be used throughout the application.
            app.component('MyComponent', MyComponent);
    
8. ASYNC COMPONENTS
    - Async components are components that are loaded asynchronously when they are needed, rather than being included in the initial bundle.
    - This can help improve the performance of the application by reducing the initial load time and allowing for code splitting.

    CREATING ASYNC COMPONENTS
        - Using defineAsyncComponent:
            ```javascript
            import { defineAsyncComponent } from 'vue';

            const AsyncComponent = defineAsyncComponent({
              loader: () => import('./MyComponent.vue'),
              loadingComponent: LoadingComponent,
              errorComponent: ErrorComponent,
              delay: 200,
              timeout: 3000
            });
            ```
9. FUNCTIONAL COMPONENTS
    - Functional components are stateless components that do not have their own instance or lifecycle methods.
    - Components without state, lifecycle hooks, or reactivity can be defined as functional components.

    // Divider.js
    import { h } from 'vue'
    export default () => h('hr', { class: 'my-divider' })

    <template>
        <div>
            <h2>Section One</h2>
            <Divider />
            <h2>Section Two</h2>
        </div>
    </template>

    <script setup>
        import Divider from './Divider.js'
    </script>

10. WAYS OF WRITING COMPONENTS

    - Option API
        - We define a component logic's using an object of options like data, methods, computed, watch, lifecycle hooks etc.
        - Properties defined by options are exposed on `this` inside functions.
        - `this` refers to the component instance.
    - Composition API
        - We define components logics using imported API functions like `ref`, `reactive`, `computed`, `watch`, `onMounted` etc.
        - In SFC's Composition API is used inside `<script setup>` block.
        - Properties defined inside `<script setup>` are directly accessible in the template without `this`.

    *NOTE* - Options API built on top of Composition API.

11. FLOW OF A VUE 3 APPLICATION
    - main.js is the entry point of the application.
    - main.js creates a Vue application instance using `createApp` and mounts it to a specific DOM element.
    - The root component (App.vue) is rendered inside the mounted DOM element.
    - createApp method accepts the root component as an argument.
    - .mount('#app') method mounts the application to the DOM element with the ID `app`.

12. USE OF `<script setup>` 

    - If we are not using `<script setup>`, we need to explicitly return the properties we want to expose to the template.

    <script>
        import { ref } from 'vue';
        export default {
            setup() {
                const message = ref('Hello World');
                return { message };
            }
        }
    </script>

    - With `<script setup>`, we don't need to return the properties, they are automatically exposed to the template.
    <script setup>
        import { ref } from 'vue';
        const message = ref('Hello World');
    </script>

13. TEMPLATE SYNTAX

    - Text Interpolation
        - {{ message }} - Interpolates the value of `message` variable.
    
    - Attribute Binding
        - v-bind:src="imageSrc" or :src="imageSrc" - Binds the `src` attribute of an image to the value of `imageSrc` variable.
        - Dynamic arguments - v-bind:[attrName]="attrValue" or :[attrName]="attrValue"
            - <div v-bind:[attrName]="attrValue"></div>
            - If attrName is "id" and attrValue is "my-div", it will render as <div id="my-div"></div>
        - Multiple attributes - v-bind="attributes"
            - <div v-bind="attributes"></div>
            - If attributes is { id: 'my-div', class: 'my-class' }, it will render as <div id="my-div" class="my-class"></div>

    - HTML Binding
        - v-html="rawHtml" - Binds the inner HTML of an element to the value of `rawHtml` variable.

    - JS Expressions
        - {{ number + 1 }} - Evaluates the expression and interpolates the result.
        - :title="`Count is ${count}`" - Evaluates the expression and binds the result to the `title` attribute.

    - Event Handling
        - v-on:click="handleClick" or @click="handleClick" - Binds the `click` event to the `handleClick` method.

***** REACTIVITY ******
    - In Vue 3, reactivity is implemented using Proxies.
    - When we define reactive state using ref() or reactive(), Vue wraps the state in a Proxy.
    - The Proxy intercepts get and set operations on the state.
    - Accessing a property triggers the get trap, allowing Vue to track dependencies.
    - Modifying a property triggers the set trap, notifying Vue of a change.
    - Vue keeps track of which components use which reactive properties so it can update only what‚Äôs necessary.
    - On template render, Vue compiles the template into a render function that produces a Virtual DOM tree.
    - When reactive data changes, Vue re-runs the render function to produce a new Virtual DOM.
    - Vue compares the new Virtual DOM with the previous one using a diffing algorithm.
    - Vue applies only the minimal set of changes to the real DOM to keep it in sync with the Virtual DOM.
    - This process enables efficient DOM updates and high performance.

14. REACTIVITY OF DATA 

    - In three ways we can bind data to the template.

        1. Without ref or reactive
            - Data is not reactive.
            - Changes to the data will not be reflected in the template.
            - Example
            <script setup>
                let count = 0
                function inc() { count++ }
            </script>

            <template>
                <p>{{ count }}</p> <!-- ‚ùå won't update -->
                <button @click="inc">+</button>
            </template>

        2. With ref
            - Data is reactive.
            - Used for primitive values (string, number, boolean).
            - Changes to the data will be reflected in the template.
            - Also works for objects/arrays if you want to replace the whole thing.
            - .value is used to access or modify the value of a ref.
            - Example
            <script setup>
                import { ref } from 'vue'

                const count = ref(0)
                function inc() { count.value++ }
            </script>

            <template>
                <p>{{ count }}</p> <!-- ‚úÖ reactive -->
                <button @click="inc">+</button>
            </template>

        3. With reactive
            - Data is reactive.
            - Used for objects and arrays you want to mutate internally.
            - Wont work with primitive data types.
            - Changes to the data will be reflected in the template.
            - No need to use .value to access or modify the properties of a reactive object.
            - We can directly access or modify the properties of a reactive object.
            - If you replace the whole object/array ‚Üí ‚ùå breaks reactivity.
            - Example
            <script setup>
                import { reactive } from 'vue'

                const state = reactive({ count: 0 })
                function inc() { state.count++ }
            </script>

            <template>
                <p>{{ state.count }}</p> <!-- ‚úÖ updates -->
                <button @click="inc">+</button>
            </template>

***** HOW TO MANAGE A STATE IN VUE 3 *****
    - In vue 3 state can be managed in several ways.
    1. Local State
        - State that is specific to a single component.
        - Managed using ref or reactive inside the component.
    2. Shared State
        - State that is shared between multiple components
        - Example: User authentication status, theme settings etc.
        - Vuex/Pinia can be used for complex shared state management.
    3. Parent-Child State Sharing
        - We can also use provide/inject API for simple shared state management between parent and child components.
    4. Simple State Sharing
        - For very simple cases, we can use an event bus or a global event emitter to share state between components. 

***** AUTH FLOW IN VUE 3 *****
    - I will create a pinia store to manage the authentication state.
    - The store will have state properties like isAuthenticated, user, token etc.
    - The store will have actions like login, logout, register, initAuth etc.
    - The store will have getters to access the state properties. like isAuthenticated, user etc.

    - I will import authStore in main.js and call initAuth action to check if the user is already logged in. like
        const authStore = useAuthStore()
        authStore.initAuth()
    - initAuth action will make an api call to check if the user is already logged in.
    - If the user is logged in, it will set the isAuthenticated to true and set the user and token properties.
    - If the user is not logged in, it will set the isAuthenticated to false and clear the user and token properties.
    - I will create a router with protected routes that can only be accessed by authenticated users.
    - I will use navigation guards to protect the routes.
        router.beforeEach((to, from, next) => {
            const authStore = useAuthStore()
            if (to.meta.requiresAuth && !authStore.isAuthenticated) {
                next('/login')
            } else {
                next()
            }
        })

***** IN VUE RE-RENDERING HAPPENS IN FOLLOW SCENARIOS *****
    - When reactive state value changes
    - Props passed from parent component changes
    - Computed value changes
    - Vuex/Pinia store state changes

    - On re-render
        - Render function runs again (template compiled result)
        - Only beforeUpdate and onUpdated runs again - other life cycle hooks wont run
        - Watch and Computed runs if dependencies changes

15. COMPUTED PROPERTIES
    - Normally we can write simple expressions in the template.
    - For complex logic, we can use methods or computed properties.
    - Methods are re-evaluated every time the component re-renders.
    - Computed properties are cached based on their reactive dependencies.
    - Computed properties are only re-evaluated when their dependencies change.
    - Computed properties are defined using the `computed` function from Vue.
    - Example
    <script setup>
        import { ref, computed } from 'vue'
        const count = ref(0)
        const doubleCount = computed(() => count.value * 2)
        function inc() { count.value++ }
    </script>
    <template>
        <p>Count: {{ count }}</p>
        <p>Double Count: {{ doubleCount }}</p>
        <button @click="inc">+</button>
    </template>
    - Computed properties are read-only by default.
    - We can define a setter for a computed property to make it writable.
    - Example
    <script setup>
        import { ref, computed } from 'vue'
        const count = ref(0)
        const doubleCount = computed({
            get: () => count.value * 2,
            set: (val) => count.value = val / 2
        })
        function inc() { count.value++ }
    </script>
    <template>
        <p>Count: {{ count }}</p>
        <p>Double Count: {{ doubleCount }}</p>
        <button @click="inc">+</button>
        <input v-model="doubleCount" />
    </template>

16. BINDING CLASS
    - We can bind class to an element using `:class` directive.
    - We can bind class using string, object or array.
    - String
        - :class="'my-class'"
    - Object
        - :class="{ 'my-class': isActive, 'another-class': isAnotherActive }"
    - Array
        - :class="[class1, class2]"
    - Example
    <script setup>
        import { ref } from 'vue'
        const isActive = ref(true)
        const isAnotherActive = ref(false)
        const class1 = 'class-one'
        const class2 = 'class-two'
    </script>
    <template>
        <div :class="'my-class'">String Class</div>
        <div :class="{ 'my-class': isActive, 'another-class': isAnotherActive }">Object Class</div>
        <div :class="[class1, class2]">Array Class</div>
    </template>

17. BINDING STYLE
    - We can bind style to an element using `:style` directive.
    - We can bind style using object or array.
    - Object
        - :style="{ color: textColor, fontSize: fontSize + 'px' }"
    - Array
        - :style="[style1, style2]"
    - Example
    <script setup>
        import { ref } from 'vue'
        const textColor = ref('red')
        const fontSize = ref(16)
        const style1 = { color: 'blue' }
        const style2 = { fontSize: '20px' }
    </script>
    <template>
        <div :style="{ color: textColor, fontSize: fontSize + 'px' }">Object Style</div>
        <div :style="[style1, style2]">Array Style</div>
    </template>

18. WHAT HAPPENS WHEN I PASS CLASS ATTR IN CHILD COMPONENT CALL 
    - When we pass class attribut where we call the child component, the class is added to the root element of the child component.
    - If the child component has multiple root elements, it will not added to any elements, it will show the warning in the console.
    - If we want to add the class to a specific element we can use :class="$attrs.class".
    - Example
    // ParentComponent.vue
    <template>
        <ChildComponent class="my-class" />
    </template>
    <script setup>
        import ChildComponent from './ChildComponent.vue'
    </script>
    // ChildComponent.vue
    <template>
        <div class="my-class"> <!-- ‚ùå won't work if multiple root elements -->
            <h2>Child Component</h2>
        </div>
    </template>
    <script setup>
    </script>

19. CONDITIONAL RENDERING
    - We can conditionaly render elements by using `v-if`, `v-else-if`, `v-else` and `v-show` directives.
    - v-if
        - Renders the element only if the condition is true.
        - The element and its children and event listeners are destroyed and re-created when the condition changes.
        - We can use this in <template> or <component> tags.
        - Will not render the element if the condition is false.
    - v-else-if
        - Renders the element if the previous v-if or v-else-if condition is false and the current condition is true.
    - v-else
        - Renders the element if all previous v-if and v-else-if conditions are false.
    - v-show
        - Toggles the visibility of the element by changing its CSS `display` property.
        - The element and its children and event listeners are always present in the DOM, but hidden when the condition is false.
        - We can use this only in normal HTML tags. In <template> or <component> tags it will show a warning in the console.
        - Always renders the element, even if the condition is false.

20. LIST RENDERING
    - We can render a list of items using `v-for` directive.
    - v-for
        - Syntax: v-for="(item, index) in items" or v-for="item in items"
        - item: The current item in the iteration.
        - index: The index of the current item in the iteration (optional).
        - items: The array or object to iterate over.
        - We should provide a unique `key` attribute for each item to help Vue track changes and optimize rendering.
        - Example
        <script setup>
            import { ref } from 'vue'
            const items = ref(['Item 1', 'Item 2', 'Item 3'])
        </script>
        <template>
            <ul>
                <li v-for="(item, index) in items" :key="index">{{ item }}</li>
            </ul>
        </template>

21. IN-PLACE PATCH STRATEGY
    - If we are rendering a list without key attribute, Vue uses in-place patch strategy.
    - In-place patch strategy means Vue will try to reuse the existing DOM elements and update their content.
    - let say if we are rendering a list with li elements without key attribute - when we are updating a list it will not create new li elements, it will reuse the existing li element and just update the value inside it.
    - This can lead to unexpected behavior when the list is modified (e.g., items are added, removed, or reordered).

    - 1. If :key is NOT present
        - Vue reuses DOM nodes based on their position (index) in the array, not the identity of the data.
        - Inserting or removing items in the middle can cause wrong DOM reuse, breaking component state.
        - Appending at the end is safe, but inserting at the start or middle can overwrite existing DOM nodes incorrectly.

    2. If :key IS present
        - Vue reuses DOM nodes based on the key value, matching each item‚Äôs identity.
        - New keys ‚Üí new DOM nodes are created.
        - Removed keys ‚Üí DOM nodes are removed.
        - Existing keys ‚Üí DOM nodes are reused safely, preserving component state and enabling optimizations like v-memo.        
    
    ‚úÖ Rule of Thumb for real apps:
    Always use a unique ID key (from DB, UUID, timestamp, etc.), never the array index, unless the list is 100% static.

22. EVENT HANDLING
    - We can listen to events using `v-on` directive or `@` shorthand.
    - v-on:click="handleClick" or @click="handleClick"
    - We can pass arguments to the event handler using inline statements.
        - @click="handleClick(arg1, arg2)"
    - We can use `$event` to access the native event object.
        - @click="handleClick($event)"
    - We can use event modifiers to modify the behavior of the event listener.
        - .stop - Stops the event from propagating (bubbling) up the DOM tree.
            - @click.stop="handleClick"
        - .prevent - Prevents the default action of the event.
            - @submit.prevent="handleSubmit"
        - .capture - Adds the event listener in capture mode.
            - @click.capture="handleClick"
        - .once - The event will be triggered at most once.
            - @click.once="handleClick"

23. .SELF MODIFIER
    - The .self modifier allows the event to be triggered only when the event target is the element itself, not its children.
    - Example
    <template>
        <div @click.self="handleClick" style="padding: 20px; border: 1px solid black;">
            Click me (only if you click on the box, not on the text)
            <p>Some text inside the box</p>
        </div>
    </template>
    <script setup>
        function handleClick() {
            alert('Box clicked!')
        }
    </script>
    - In this example, clicking on the div will trigger the handleClick method, but clicking on the p element inside the div will not trigger it.

24. FORM INPUT BINDING
    - We can bind form inputs using `v-model` directive.
    - v-model creates a two-way binding between the form input and the data property.
    - input (text, password, email, etc.)
        - for input fields v-model is the combination of :value and @input
            - <input v-model="text" />
            - is equivalent to
            - <input :value="text" @input="text = $event.target.value" />
    - textarea
        - for textarea v-model is the combination of :value and @input
            - <textarea v-model="message"></textarea>
    - checkbox
        - for checkbox v-model is the combination of :checked and @change
        - <input type="checkbox" v-model="isChecked" />
            - is equivalent to
            - <input type="checkbox" :checked="isChecked" @change="isChecked = $event.target.checked" />
        - We can set values for checkbox using `true-value` and `false-value` attributes.
            - <input type="checkbox" v-model="isChecked" true-value="yes" false-value="no" />
            - is equivalent to
            - <input type="checkbox" :checked="isChecked === 'yes'" @change="isChecked = $event.target.checked ? 'yes' : 'no'" />
        - for multiple checkboxes bound to an array
            - <input type="checkbox" v-model="selectedOptions" value="Option 1" />
            - <input type="checkbox" v-model="selectedOptions" value="Option 2" />
            - is equivalent to
            - <input type="checkbox" :checked="selectedOptions.includes('Option 1')" @change="updateSelectedOptions('Option 1', $event.target.checked)" />
            - <input type="checkbox" :checked="selectedOptions.includes('Option 2')" @change="updateSelectedOptions('Option 2', $event.target.checked)" />
            - function updateSelectedOptions(option, isChecked) {
                if (isChecked) {
                    selectedOptions.push(option)
                } else {
                    const index = selectedOptions.indexOf(option)
                    if (index > -1) {
                        selectedOptions.splice(index, 1)
                    }
                }
            }
    - radio
        - for radio buttons v-model is the combination of :checked and @change
            - <input type="radio" v-model="picked" value="Option 1" />
            - <input type="radio" v-model="picked" value="Option 2" />
            - is equivalent to
            - <input type="radio" :checked="picked === 'Option 1'" @change="picked = 'Option 1'" />
            - <input type="radio" :checked="picked === 'Option 2'" @change="picked = 'Option 2'" />
    - select
        - for select dropdown v-model is the combination of :value and @change
            - <select v-model="selected">
                <option value="Option 1">Option 1</option>
                <option value="Option 2">Option 2</option>
            </select>
            - is equivalent to
            - <select :value="selected" @change="selected = $event.target.value">
                <option value="Option 1">Option 1</option>
                <option value="Option 2">Option 2</option>
            </select>

25. MODIFIERS IN V-MODEL
    - We can use modifiers with v-model to modify its behavior.
    - .lazy
        - Updates the data property only when the input loses focus (on blur event).
        - <input v-model.lazy="text" />
    - .number
        - Converts the input value to a number before updating the data property.
        - <input v-model.number="age" />
    - .trim
        - Trims whitespace from the input value before updating the data property.
        - <input v-model.trim="name" />
    - Example
    <script setup>
        import { ref } from 'vue'
        const text = ref('')
        const age = ref(0)
        const name = ref('')
    </script>
    <template>
        <input v-model.lazy="text" placeholder="Lazy Input" />
        <input v-model.number="age" placeholder="Number Input" />
        <input v-model.trim="name" placeholder="Trim Input" />
        <p>Text: {{ text }}</p>
        <p>Age: {{ age }}</p>
        <p>Name: {{ name }}</p>
    </template>

26. WATCHER
    - We can watch the changes in the data properties using `watch` function from Vue.
    - It allows us to perform side effects when the watched property changes.
    - Example
    <script setup>
        import { ref, watch } from 'vue'
        const count = ref(0)
        watch(count, (newValue, oldValue) => {
            console.log(`Count changed from ${oldValue} to ${newValue}`)
        })
        function inc() { count.value++ }
    </script>
    <template>
        <p>Count: {{ count }}</p>
        <button @click="inc">+</button>
    </template>

    - It takes three arguments: source to watch, callback function and options (optional).
        - source: The data property or a function that returns the data property to watch.
        - callback: A function that is called when the watched property changes. It receives the new value and the old value as arguments.
        - options: An optional object that can contain the following properties:
            - immediate: If true, the callback is called immediately with the current value of the watched property.
            - deep: If true, the watcher will also watch for changes in nested properties of the watched object.

27. SOURCE TYPES IN WATCHER
    - We can watch different types of sources using the `watch` function.
    - Ref
        - We can watch a ref property directly.
        - Example
        const count = ref(0)
        watch(count, (newValue, oldValue) => {
            console.log(`Count changed from ${oldValue} to ${newValue}`)
        })
    - Getter Function
        - We can watch a getter function that returns a value derived from one or more reactive properties.
        - Example
        const count = ref(0)
        const doubleCount = computed(() => count.value * 2)
        watch(doubleCount, (newValue, oldValue) => {
            console.log(`Double Count changed from ${oldValue} to ${newValue}`)
        })
    - Multiple Sources
        - We can watch multiple sources by passing an array of refs or getter functions.
        - Example
        const x = ref(0)
        const y = ref(0)
        watch([x, y], ([newX, newY], [oldX, oldY]) => {
            console.log(`x changed from ${oldX} to ${newX}, y changed from ${oldY} to ${newY}`)
        })
    - Reactive Object
        - We can watch a reactive object to track changes in its properties.
        - Issue with this is we cant get previous value of the object.
        - Both newObj and oldObj will point to the same object in memory.
        - Example
        const obj = reactive({ count: 0 })
        watch(obj, (newObj, oldObj) => {
            console.log(`Obj changed from ${JSON.stringify(oldObj)} to ${JSON.stringify(newObj)}`)
        });

        - We cant directly watch object properties. We need to use getter function.
        - Example
        const obj = reactive({ count: 0 })
        watch(() => obj.count, (newCount, oldCount) => {
            console.log(`Count changed from ${oldCount} to ${newCount}`)
        })

    ****IMPORTANT****
        - Source type of watch should be ref, reactive object or getter function.
        - Example : If you are trying watch properties of a reactive object directly it will not work. because properties are not reactive individually.

28. DEEP AND IMMEDIATE OPTIONS IN WATCHER
    - deep
        - If true, the watcher will also watch for changes in nested properties of the watched object.
        
            const nestObj = reactive({ count: { value: 10, name: 'test' }})

            watch(nestObj, (newVal, oldVal) => {
                console.log('watch(nestObj): fired', newVal.count.value, oldVal.count.value)
            })

            // Behavior:
            //     ‚úÖ Fires when you change nestObj.count.value
            //     ‚úÖ Fires when you change nestObj.count.name
            //     ‚úÖ Fires when you replace nestObj.count

            // üëâ Why? Because passing a reactive object directly makes Vue treat it as a deep watch automatically.

            watch(()=> nestObj, (newVal, oldVal) => {
                console.log('watch(() => nestObj): fired', newVal.count.value, oldVal.count.value)
            })

            // Behavior:
            //     ‚ùå Does not fire when you change nestObj.count.value
            //     ‚ùå Does not fire when you change nestObj.count.name
            //     ‚úÖ Fires only if you replace the whole object:

            // üëâ Why? Because here you‚Äôre watching the reference to nestObj. The reference doesn‚Äôt change when you mutate its properties.

            watch(()=> nestObj, (newVal, oldVal) => {
                console.log('watch(() => nestObj, deep: true): fired', newVal.count.value, oldVal.count.value)
            }, { deep: true })

            // Behavior:
            //     ‚úÖ Fires when you change nestObj.count.value
            //     ‚úÖ Fires when you change nestObj.count.name
            //     ‚úÖ Fires when you replace nestObj.count

            // üëâ Same behavior as Case 1, but here you had to explicitly tell Vue to go deep.

            // Watch a specific property - always be getter function
            watch(() => nestObj.count.value, (newVal, oldVal) => {
                console.log('watch(nestObj.count.value):', newVal, oldVal)
            })

    - immediate
        - If true, the callback is called immediately with the current value of the watched property.
        - Example
        const count = ref(0)
        watch(count, (newValue, oldValue) => {
            console.log(`Count changed from ${oldValue} to ${newValue}`)
        }, { immediate: true })

29. WATCHEFFECT && WATCHPOSTEFFECT
    - watchEffect
        - It runs the provided function immediately and tracks all reactive dependencies used inside the function.
        - Whenever any of the tracked dependencies change, the function is re-executed.
        - It does not provide access to previous values of the dependencies.
        - Example
        <script setup>
            import { ref, watchEffect } from 'vue'
            const count = ref(0)
            watchEffect(() => {
                console.log(`Count is: ${count.value}`)
            })
            function inc() { count.value++ }
        </script>
        <template>
            <p>Count: {{ count }}</p>
            <button @click="inc">+</button>
        </template>

    - watchPostEffect
        - Similar to watchEffect, but the provided function is executed after the DOM has been updated.
        - It is useful for performing side effects that depend on the updated DOM state.
        - Example
        <script setup>
            import { ref, watchPostEffect } from 'vue'
            const count = ref(0)
            watchPostEffect(() => {
                console.log(`Count is: ${count.value}`)
                // Perform DOM-related side effects here
            })
            function inc() { count.value++ }
        </script>
        <template>
            <p>Count: {{ count }}</p>
            <button @click="inc">+</button>
        </template>

    - Key Differences
        - Execution Timing: watchEffect runs immediately when defined and whenever its dependencies change, while watchPostEffect runs after the DOM has been updated.
        - Use Cases: watchEffect is suitable for general reactive side effects, while watchPostEffect is ideal for side effects that depend on the updated DOM state.
        - Dependency Tracking: Both functions automatically track reactive dependencies used within their provided functions.

    - Choosing Between Them
        - Use watchEffect when you need to react to changes in reactive data and perform side effects that do not depend on the DOM state.
        - Use watchPostEffect when your side effects require access to the updated DOM, such as manipulating DOM elements or measuring their dimensions after a change.

    - Summary
        - Both watchEffect and watchPostEffect are powerful tools for managing side effects in Vue 3 applications. 
        - The choice between them depends on whether your side effects need to interact with the DOM after it has been updated or can be executed immediately upon dependency changes.

30. LIFECYCLE HOOKS
    - Lifecyscle hooks allows us to run code at specific stages of a component's lifecycle.
    - We can have multiple lifecycle hooks of the same type in a component.

    1. onBeforeMount
        - Runs before the component is mounted to the DOM.
        - We can use this hook to perform any setup or initialization that needs to happen before the component is rendered.
        - DOM is not yet available.

    2. onMounted
        - Runs after the component is mounted to the DOM.
        - We can use this hook to perform any setup or initialization that needs to happen after the component is rendered.
        - DOM is available.
    
    3. onBeforeUnmount
        - Runs before the component is unmounted from the DOM.
        - We can use this hook to perform any cleanup or teardown that needs to happen before the component is removed from the DOM.
        - DOM is still available.

    4. onUnmounted
        - Runs after the component is unmounted from the DOM.
        - We can use this hook to perform any cleanup or teardown that needs to happen after the component is removed from the DOM.
        - DOM is not available.

    5. onBeforeUpdate
        - Runs before the component is updated.
        - DOM is still available.   

    6. onUpdated
        - Runs after the component is updated.
        - DOM is available.

31. TEMPLATE REFS
    - Template refs allows us to access DOM elements or component instances directly in the script.
    - We can create a template ref by adding the `ref` attribute to an element or component in the template.
    - We can access the ref in the script using the `ref` function from Vue.
    - Example
    <template>
        <input ref="inputRef" type="text" />
        <button @click="focusInput">Focus Input</button>
    </template>
    <script setup>
        import { ref } from 'vue'
        const inputRef = ref(null)
        function focusInput() {
            inputRef.value.focus()
        }
    </script>
    
    - Function Ref
        - <div :ref="(el) => updateRef(el)"> Another Div</div>

32. DEFINEEXPOSE
    - By default, only the props and events of a child component are accessible to the parent component.
    - If we want to expose additional properties or methods from the child component to the parent component, we can use `defineExpose`.
    - We can define the properties or methods we want to expose in an object passed to `defineExpose`.
    - Example
    // ChildComponent.vue
    <template>
        <div>Child Component</div>
    </template>
    <script setup>
        import { ref, defineExpose } from 'vue'
        const count = ref(0)
        function increment() {
            count.value++
        }
        defineExpose({
            count,
            increment
        })
    </script>

    // ParentComponent.vue
    <template>
        <ChildComponent ref="childRef" />
        <p>Count from Child: {{ childRef.count }}</p>
        <button @click="childRef.increment()">Increment Child Count</button>
    </template>
    <script setup>
        import { ref } from 'vue'
        import ChildComponent from './ChildComponent.vue'
        const childRef = ref(null)
    </script>

    - In this example, the `ChildComponent` exposes its `count` property and `increment` method using `defineExpose`. 
    - The `ParentComponent` can then access these exposed members through the `childRef` reference.

33. COMPONENTS REGISTARTION AND ITS DRAWBACKS
    - Local Registration
        - We can register a component locally within another component using the `components` option.
        - The registered component is only available within the parent component.
        - Example
        <script setup>
            import ChildComponent from './ChildComponent.vue'
        </script>
        <template>
            <ChildComponent />
        </template>
        - Drawbacks
            - We need to import and register the component in every parent component where we want to use it.
            - Can lead to repetitive code if the same component is used in multiple places.

    - Global Registration
        - We can register a component globally using the `app.component` method on the Vue application instance.
        - The registered component is available throughout the entire application without needing to import or register it in each parent component.
        - Example
        import { createApp } from 'vue'
        import App from './App.vue'
        import GlobalComponent from './GlobalComponent.vue'

        const app = createApp(App)
        app.component('GlobalComponent', GlobalComponent)
        app.mount('#app')
        - Drawbacks
            - Can lead to naming conflicts if multiple components have the same name.
            - Makes it harder to track where a component is being used, as it can be used anywhere in the application.
            - Tree-shaking may not work effectively, potentially increasing the bundle size if many global components are registered but not used.

    - Best Practices
        - Use local registration for components that are only used in a few places or are specific to a particular feature or module.
        - Use global registration for components that are widely used across the application, such as UI components (buttons, modals, etc.) or layout components (headers, footers, etc.).
        - Consider using a naming convention for globally registered components to avoid naming conflicts (e.g., prefixing with "App" or "Ui").

34. TREE-SHAKING AND CODE SPLITTING
    - Tree-shaking is a technique used to eliminate unused code from the final bundle, reducing its size and improving performance.
    - Code splitting is a technique used to split the application into smaller chunks that can be loaded on demand, improving the initial load time of the application.
    - Both techniques are important for optimizing the performance of Vue applications, especially as they grow in size and complexity.

    LOCAL REGISTRATION
        - Local registration can benefit from tree-shaking because only the components that are imported and used in a parent component are included in the final bundle.
        - If a component is not imported or used, it will be eliminated from the bundle during the tree-shaking process.

    GLOBAL REGISTRATION
        - Global registration can hinder tree-shaking because all globally registered components are included in the final bundle, regardless of whether they are used or not.
        - This can lead to larger bundle sizes and slower load times, especially if many global components are registered but not used.

    CODE SPLITTING
        - Code splitting can be achieved using dynamic imports with local registration.
        - By using dynamic imports, we can load components only when they are needed, reducing the initial load time of the application.    

35. PROPS
    - Props are used to pass data from a parent component to a child component.
    - We can define props in a child component using the `defineProps` function from Vue.
    - We can specify the type, default value, validation, and whether the prop is required or not.
    - props are reactive, meaning that if the parent component updates the prop value, the child component will automatically re-render with the new value.
    - props values are immutable in the child component, meaning that we should not modify the prop value directly in the child component.
    - If we trying to primitive value directly in the child component, it will show a warning in the console.
    - If we want to modify the prop value in the child component, we should create a local copy of the prop value using `ref` or `reactive`.
    - In case of arrays and objects, we can modify the internal properties of props , but it updates the parent component as well, which can lead to unexpected behavior.
    - Example
    const props = defineProps({
        propDetails: Object,
        changeTitle: { type: Function, default: () => {} },
        pageTitle: { type: String, default: "Blogs" },
        postId: { type: [String, Number], required: true },
        postType: { type: String, validator : (value) => ['story', 'news'].includes(value)}
    })

36. EMITS
    - Emits are used to send events from a child component to a parent component.
    - We can define emits in a child component using the `defineEmits` function from Vue.
    - We can specify the event names and their payload types.
    - We can emit events using the `emit` function returned by `defineEmits`.
    - Example
    const emit = defineEmits(['update', 'delete'])

    function updateItem(item) {
        emit('update', item)
    }

    function deleteItem(itemId) {
        emit('delete', itemId)
    }

    - We can also validate the payload of the emitted events by defining the event names and their payload types in an object.
    - Example
    const emit = defineEmits({
        update: (item) => typeof item === 'object' && item !== null,
        delete: (itemId) => typeof itemId === 'string' || typeof itemId === 'number'
    })

37. V-MODEL ON COMPONENTS
    - We can use `v-model` directive on custom components to create a two-way binding between a parent component and a child component.
    - By default, `v-model` uses the `modelValue` prop and the `update:modelValue` event for binding.
    - In the child component, we need to define the `modelValue` prop using `defineProps` and emit the `update:modelValue` event using `defineEmits`.
    - Example
    // ChildComponent.vue
        <template>
            <input :value="modelValue" @input="updateValue($event.target.value)" />
        </template>
        <script setup>
            const props = defineProps({
                modelValue: String
            })
            const emit = defineEmits(['update:modelValue'])
            function updateValue(value) {
                emit('update:modelValue', value)
            }
        </script>

        // ParentComponent.vue
        <template>
            <ChildComponent v-model="text" />
            <p>Text: {{ text }}</p>
        </template>

    - We can bind multiple `v-model` directives to a single component by using different prop and event names.
    - We can customize the prop and event names used by `v-model` by using the `model` option in the child component.
    - Example
    // ChildComponent.vue
        <template>  
            <input :value="title" @input="updateTitle($event.target.value)" />
            <textarea :value="content" @input="updateContent($event.target.value)"></textarea>
        </template>
        <script setup>
            const props = defineProps({
                title: String,
                content: String
            })
            const emit = defineEmits(['update:title', 'update:content'])
            function updateTitle(value) {
                emit('update:title', value)
            }
            function updateContent(value) {
                emit('update:content', value)
            }
        </script>
        // ParentComponent.vue
        <template>
            <ChildComponent v-model:title="postTitle" v-model:content="postContent" />
            <p>Title: {{ postTitle }}</p>
            <p>Content: {{ postContent }}</p>
        </template>
        <script setup>
            import { ref } from 'vue'
            const postTitle = ref('')
            const postContent = ref('')
        </script>

38. CUSTOM MODIFIERS IN V-MODEL
    - We can create custom modifiers for `v-model` by defining a custom prop and event names in the child component.
    - We can then use these custom prop and event names in the parent component with `v-model`.
    - Vue‚Äôs v-model modifiers (.capitalize, .debounce, etc.) only work when a component is being used by a parent.
    - Inside the same component, Vue doesn‚Äôt inject modelModifiers automatically (because there‚Äôs no parent binding).
    - Example
    // ChildComponent.vue
        <script setup>
            const props = defineProps({
                title: { type: String, default: '' },
                titleModifiers: { type: Object, default: () => {}}
            })
            const emit = defineEmits(['update:title']);
            const update = (e) => {
                let value = e.target.value;
                if(props.titleModifiers['no-hyphens']) {
                    value = value.split("-").join("");
                }
                emit('update:title', value)
            }
        </script>
        <template>
            <h1>Custom Input</h1>
            <div>
                <input type="text" name="title" id="title" :value="title" @input="update">
            </div>
        </template>
    // ParentComponent.vue
        <script setup>
            import { ref } from 'vue'
            import ChildComponent from './ChildComponent.vue'
            const title = ref('');
        </script>
        <template>
            <ChildComponent v-model:title.no-hyphens="title"/>
            {{ title }}
        </template>

39. FALLTHROUGH ATTRIBUTES - ATTRIBUTES INHERITANCE
    - If we are passing any attributes (class, id, style, events) to child component, if those are not defined as props or emits in the child component, 
        those attributes will be added to the root element of the child component.
    - This is known as "fallthrough attributes" or "attributes inheritance".
    - It will merge the attributes with the root element of the child component. if same attribute is defined in both parent and child component, the value from the parent component will take precedence.
    - click events will also be merged, both parent and child click events will be triggered.
    - For nested components, the fallthrough attributes will be added to the root element of the outermost child component.
    - Example
    // ChildComponent.vue
        <template>
            <div>Child Component</div>
        </template>
        <script setup>
        </script>
    // ParentComponent.vue
        <template>
            <ChildComponent class="my-class" id="my-id" data-info="some-data" />
        </template>
        <script setup>
            import ChildComponent from './ChildComponent.vue'
        </script>
    - In this example, the `class`, `id`, and `data-info` attributes will be added to the root `<div>` element of the `ChildComponent`.

    - If the child component has multiple root elements, fallthrough attributes will not be added to any elements, and a warning will be shown in the console.
    - If we want to add the attributes to a specific element in the child component, we can use `v-bind="$attrs"` on that element.
    - Example
    // ChildComponent.vue
        <template>
            <div v-bind="$attrs">Child Component</div>
            <p>Another Element</p>
        </template>
        <script setup>
        </script>
    - In this example, the fallthrough attributes will be added to the `<div>` element, but not to the `<p>` element.

40. DISABLE ATTRIBUTES INHERITANCE
    - In vue 3 we can disable fallthrough attributes by setting `inheritAttrs` to false in the child component.
    - Example
    // ChildComponent.vue
        <template>
            <div>Child Component</div>
        </template>
        <script setup>
            defineOptions({ inheritAttrs: false })
        </script>
    - In this example, the fallthrough attributes will not be added to any elements in the `ChildComponent`.

41. USEATTRS
    - We can access the fallthrough attributes in the child component using the `useAttrs` function from Vue.
    - `useAttrs` returns a reactive object containing all the fallthrough attributes passed to the component.
    - Example
        <script setup>
            import { useAttrs } from 'vue'
            const attrs = useAttrs()
        </script>

42. SLOTS | NAMED SLOTS | SCOPED SLOTS
    - Slots are used to pass content from a parent component to a child component.
    - We can define slots in a child component using the `<slot>` element in the template.
    - We can pass content to the slots in the parent component by placing the content between the opening and closing tags of the child component.
    - Default Slot
        - If we define a slot without a name, it is considered as the default slot.
        - Example
        // ChildComponent.vue
            <template>
                <div>
                    <h2>Child Component</h2>
                    <slot></slot>
                </div>
            </template>
            <script setup>
            </script>
        // ParentComponent.vue
            <template>
                <ChildComponent>
                    <p>This is some content for the default slot.</p>
                </ChildComponent>
            </template>
            <script setup>
                import ChildComponent from './ChildComponent.vue'
            </script>

    - Named Slots
        - We can define multiple named slots in a child component by adding the `name` attribute to the `<slot>` element.
        - We can pass content to named slots in the parent component by using the `v-slot` directive or the shorthand `#` syntax.
        - Example
        // ChildComponent.vue
            <template>
                <div>
                    <h2>Child Component</h2>
                    <slot name="header"></slot>
                    <slot></slot> <!-- Default Slot -->
                    <slot name="footer"></slot>
                </div>
            </template>
            <script setup>
            </script>
        // ParentComponent.vue
            <template>
                <ChildComponent>
                    <template #header>
                        <h3>This is the header slot content.</h3>
                    </template>

                    <p>This is some content for the default slot.</p>

                    <template v-slot:footer>
                        <p>This is the footer slot content.</p>
                    </template>
                </ChildComponent>
            </template>
            <script setup>
                import ChildComponent from './ChildComponent.vue'
            </script>

    - Scoped Slots
        - Scoped slots allow us to pass data from a child component to a parent component through slots.
        - We can define scoped slots in a child component by adding a `v-slot` directive with a scope variable to the `<slot>` element.
        - We can access the scoped data in the parent component by using the scope variable in the `v-slot` directive or the shorthand `#` syntax.
        - Example
        // ChildComponent.vue
            <template>
                <div>
                    <h2>Child Component</h2>
                    <slot :message="message"></slot>
                </div>
            </template>
            <script setup>
                import { ref } from 'vue'
                const message = ref('Hello from Child Component!')
            </script>
        // ParentComponent.vue
            <template>
                <ChildComponent>
                    <template #default="{ message }">
                        <p>{{ message }}</p>
                    </template>
                </ChildComponent>
            </template>
            <script setup>
                import ChildComponent from './ChildComponent.vue'
            </script>
    - In this example, the `ChildComponent` defines a scoped slot that passes a `message` variable to the parent component. 

43. PROP DRILLING
    - Prop drilling is the process of passing data from a parent component to a child component through multiple levels of nested components.
    - It can lead to code that is hard to maintain and understand, especially when the data needs to be passed through many levels of components.
    - To avoid prop drilling, we can use state management libraries like Vuex or Pinia, or we can use the provide/inject API in Vue.
    - Example of prop drilling
    // GrandParentComponent.vue
        <template>
            <ParentComponent :data="data" />
        </template>
        <script setup>
            import { ref } from 'vue'
            import ParentComponent from './ParentComponent.vue'
            const data = ref('Some data')
        </script>
    // ParentComponent.vue
        <template>
            <ChildComponent :data="data" />
        </template>
        <script setup>
            import ChildComponent from './ChildComponent.vue'
            const props = defineProps({
                data: String
            })
        </script>
    // ChildComponent.vue
        <template>
            <p>{{ data }}</p>
        </template>
        <script setup>
            const props = defineProps({
                data: String
            })
        </script>

44. PROVIDE / INJECT
    - The provide/inject API allows us to share data between a parent component and its descendants without having to pass the data through multiple levels of components.
    - We can use the `provide` function in the parent component to provide data to its descendants.
    - We can use the `inject` function in the descendant components to access the provided data.
    - We can provide any type of data, including primitive values, objects, and functions.
    - The provided data is reactive, meaning that if the parent component updates the provided data, the descendant components will automatically re-render with the new value.
    - The provided data is not limited to direct children; it can be accessed by any descendant component in the component tree.
    - We can provide data from app level using `app.provide` method, and we can inject that data in any component in the application.
    - Example
    // ParentComponent.vue
        <template>
            <ChildComponent />
        </template>
        <script setup>
            import { provide } from 'vue'
            import ChildComponent from './ChildComponent.vue'
            const data = 'Some data'
            provide('data', data)
        </script>
    // ChildComponent.vue
        <template>
            <GrandChildComponent />
        </template>
        <script setup>
            import GrandChildComponent from './GrandChildComponent.vue'
        </script>
    // GrandChildComponent.vue
        <template>
            <p>{{ data }}</p>
        </template>
        <script setup>
            import { inject } from 'vue'
            const data = inject('data')
        </script>

45. DEFINEASYNCCOMPONENT
    - We can define async components using the `defineAsyncComponent` function from Vue.
    - It allows us to load components lazily, which can improve the initial load time of the application.
    - We can provide a factory function that returns a promise that resolves to the component definition.
    - We can also provide options for loading and error states, as well as a timeout for loading the component.
    - Example
    <script setup>
        import { defineAsyncComponent } from 'vue'
        const AsyncComponent = defineAsyncComponent(() => import('./AsyncComponent.vue'))
        const AsyncTodoComponent = defineAsyncComponent({
            loader: () => {
                return new Promise(function (resolve, reject) {
                    setTimeout(() => {
                        resolve(import ('./TodoList.vue'))
                    }, 3000);
                })
            },
            loadingComponent: Loader,
            errorComponent: Error
        })
    </script>
    <template>
        <AsyncComponent />
        <AsyncTodoComponent />
    </template>

46. COMPOSABLES
    - Composables are reusable functions that encapsulate logic and state, allowing us to share functionality across multiple components.
    - We can create composables by defining a function that uses Vue's reactivity system (e.g., `ref`, `reactive`, `computed`, `watch`, etc.) and returns the reactive state and methods.
    - We can then import and use the composable function in any component where we need the shared functionality.
    - Composables help to keep our components clean and focused on their specific responsibilities, while also promoting code reuse and maintainability.
    - Example
    // useCounter.js
        import { ref } from 'vue'
        export function useCounter() {
            const count = ref(0)
            function increment() {
                count.value++
            }
            function decrement() {
                count.value--
            }
            return {
                count,
                increment,
                decrement
            }
        }
    // CounterComponent.vue
        <template>
            <p>Count: {{ count }}</p>
            <button @click="decrement">-</button>
            <button @click="increment">+</button>
        </template>
        <script setup>
            import { useCounter } from './useCounter.js'
            const { count, increment, decrement } = useCounter()
        </script>
    
    - We can also create composables that accept parameters to customize their behavior.
    - Example
    // useFetch.js
        import { ref } from 'vue'
        export function useFetch(url) {
            const data = ref(null)
            const error = ref(null)
            const loading = ref(false)
            async function fetchData() {
                loading.value = true
                try {
                    const response = await fetch(url)
                    data.value = await response.json()
                } catch (err) {
                    error.value = err
                } finally {
                    loading.value = false
                }
            }
            return {
                data,
                error,
                loading,
                fetchData
            }
        }
    // FetchComponent.vue
        <template>
            <div v-if="loading">Loading...</div>
            <div v-else-if="error">Error: {{ error.message }}</div>
            <div v-else-if="data">{{ data }}</div>
            <button @click="fetchData">Fetch Data</button>
        </template>
        <script setup>
            import { useFetch } from './useFetch.js'
            const { data, error, loading, fetchData } = useFetch('https://api.example.com/data')
        </script>   
    
47. UNREF
    - The `unref` function is used to get the raw value from a ref or return the value itself if it's not a ref.
    - It is useful when we want to work with the actual value of a ref without having to access the `.value` property.
    - Example
    import { ref, unref } from 'vue'
    const count = ref(0)
    console.log(unref(count)) // 0
    console.log(unref(5)) // 5

48. STATEFUL VS STATELESS
    - Stateful Logic
        - Stateful logic in composables refers to the use of reactive state (e.g., `ref`, `reactive`) within the composable function.
        - This allows the composable to maintain its own internal state that can be shared across multiple components.
        - counters, fetching API data (useFetch), managing UI state (modals, toggles), stores (Pinia/Vuex).
        - Example
        // useCounter.js
            import { ref } from 'vue'
            export function useCounter() {
                const count = ref(0)
                function increment() {
                    count.value++
                }
                function decrement() {
                    count.value--
                }
                return {
                    count,
                    increment,
                    decrement
                }
            }
    - Stateless Logic
        - Stateless logic in composables refers to functions that do not maintain any internal state and simply perform operations based on the input parameters.
        - These composables are typically pure functions that return a result without any side effects.
        - formatting, validation, pure calculations, string/date utilities.
        - Example
        // useMath.js
            export function add(a, b) {
                return a + b
            }
            export function subtract(a, b) {
                return a - b
            }
            export function multiply(a, b) {
                return a * b
            }

49. DIRECTIVES
    - Directives are special attributes in Vue that provide additional functionality to HTML elements.
    - We can create custom directives using the `directive` function from Vue.
    - A directive is an object with lifecycle hooks that allow us to manipulate the DOM element when the directive is bound, updated, or unbound.
    - It has 4 arguments
        - el: The element the directive is bound to.
        - binding: An object containing the value, oldValue, arg, modifiers, and instance of the directive.
        - vnode: The virtual node produced by Vue's compiler.
        - prevVnode: The previous virtual node, only available in the `updated` and `beforeUnmount` hooks.
    - Example
        app.directive('focus', {
            mounted(el) {
                el.focus()
            }
        })
    - We can use the custom directive in the template by adding the `v-` prefix to the directive name.
    - Example
        <template>
            <input v-focus />
        </template>
        <script setup>
        </script>

50. IMPORTANT DIRECTIVES
    - v-pre
        - Skips compilation for this element and all its children.
        - Useful for displaying raw mustache tags or when we want to skip compilation for performance reasons.
        - Example
        <div v-pre>{{ rawMustache }}</div> - {{ rawMustache }} - displayed as is.
    -v-once
        - The element and its children will only be rendered once.
        - Subsequent updates to the data will not affect the element.
        - Example
        <button v-once>{{ count }}</button> - count will not update on re-renders.
    - v-cloak
        - Stays on the element until the Vue instance is fully compiled.
        - Got removed automatically once Vue is ready.
        - Used to hide uncompiled template content until Vue has fully mounted the component and compiled the template
        - Useful to prevent the flash of uncompiled mustache tags before Vue takes over.
        - Example
        <div v-cloak>{{ message }}</div> - message will not be visible until Vue is ready.

        <style>
            [v-cloak] {
                display: none;
            }
        </style>
    - v-memo
        - Memoize the element and its children.
        - It stores the previous render output and only re-renders if the dependencies change.
        - If the dependencies do not change, Vue will skip re-rendering the element and its children.
        - Useful for optimizing performance by avoiding unnecessary re-renders.
        - If we are not passing any dependencies, it will behave like `v-once`.
        - v-memo will not work inside `v-for` loops. If we add `v-memo` inside a `v-for`, it will be ignored.
        - Example
        <div v-memo="[dependency1, dependency2]">
            <!-- This element will only re-render if dependency1 or dependency2 change -->
            {{ computedValue }}
        </div>
    - v-is
        - Dynamically bind a component or element to be rendered.
        - The value can be a string (for HTML elements) or a component object.
        - Useful for rendering different components or elements based on dynamic conditions.
        - Example
        <component v-is="currentComponent" />
        <div v-is="dynamicElement"></div> <!-- dynamicElement can be 'div', 'span', etc. -->
            <script setup>
                import MyRow from './MyRow.vue'
            </script>
            <template>
                <table border="1">
                    <thead>
                    <tr>
                        <th>ID</th>
                        <th>Fruit</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr v-is="MyRow" :data="{ id: 1, name: 'Apple' }" />
                    <tr v-is="MyRow" :data="{ id: 2, name: 'Orange' }" />
                    <tr v-is="MyRow" :data="{ id: 3, name: 'Banana' }" />
                    </tbody>
                </table>
            </template>

            <script setup>
            import { defineProps } from 'vue'
            // Receive props passed from parent <tr v-is="MyRow" :data="..." />
            const props = defineProps({
            data: {
                type: Object,
                required: true,
            },
            })
            </script>

            <template>
            <!-- ‚ö†Ô∏è Root element here MUST be <tr> for table semantics -->
            <tr>
                <td>{{ props.data.id }}</td>
                <td>{{ props.data.name }}</td>
            </tr>
            </template>

51. TRANSITION
    - Vue provides a built-in `<transition>` component that allows us to apply transition effects to elements or components when they are inserted, updated, or removed from the DOM.
    - We can wrap the element or component we want to apply the transition to with the `<transition>` component.
    - We can specify the transition name using the `name` attribute on the `<transition>` component.
    - We can define CSS classes for the different stages of the transition using the transition name as a prefix.
    - <transition> will only work on a single element or component. If we want to apply the transition to multiple elements, we can use the `<transition-group>` component.
    - We can also use JavaScript hooks to define custom transition behavior using the `v-on` directive on the `<transition>` component.
    - The available hooks are `before-enter`, `enter`, `after-enter`, `before-leave`, `leave`, `after-leave`.
    - If you want to see the transition on page load, you can use `appear` attribute on the `<transition>` component.
    - Mode attribute
        - The `mode` attribute on the `<transition>` component allows us to control the timing of entering and leaving transitions when both are happening simultaneously.
        - It can take three values: `in-out`, `out-in`, and `default`.
        - `in-out`: The new element will enter first, and once the enter transition is complete, the old element will leave.
        - `out-in`: The old element will leave first, and once the leave transition is complete, the new element will enter.
        - `default`: Both enter and leave transitions will happen simultaneously.
    - Example with all features
    <template>
        <button @click="show = !show">Toggle</button>
        <transition name="fade" mode="out-in" appear
            @before-enter="beforeEnter"
            @enter="enter"
            @after-enter="afterEnter"
            @before-leave="beforeLeave"
            @leave="leave"
            @after-leave="afterLeave"
        >
            <p v-if="show">Hello, Vue 3 Transitions!</p>
        </transition>
    </template>
    <script setup>
        import { ref } from 'vue'
        const show = ref(false)
        function beforeEnter(el) {
            console.log('Before Enter', el)
        }
        function enter(el, done) {
            console.log('Enter', el)
            done()
        }
        function afterEnter(el) {
            console.log('After Enter', el)
        }
        function beforeLeave(el) {
            console.log('Before Leave', el)
        }
        function leave(el, done) {
            console.log('Leave', el)
            done()
        }
        function afterLeave(el) {
            console.log('After Leave', el)
        }
    </script>
    <style>
        .fade-enter-active, .fade-leave-active {
            transition: opacity 0.5s;
        }
        .fade-enter-from, .fade-leave-to {
            opacity: 0;
        }
        .fade-enter-to, .fade-leave-from {
            opacity: 1;
        }
    </style>

52. TRANSITIONGROUP
    - The `<transition-group>` component is used to apply transition effects to a list of elements or components that are rendered using `v-for`.
    - It works similarly to the `<transition>` component, but it is specifically designed for lists.
    - Elements should have a unique `key` attribute when using `<transition-group>`, which helps Vue to track the elements and apply the transitions correctly.
    - Example
    <template>
        <div><button @click.prevent="addItem">Add</button></div>
        <ul>
            <TransitionGroup name="list" appear>
                <li v-for="(item,index) in list" style="padding: 4px;" :key="item">
                    {{ item }} - <button @click.prevent="removeItem(index)">&#x2715;</button>
                </li>
            </TransitionGroup>
        </ul>
    </template>
    <script setup>
        import { ref, TransitionGroup } from 'vue';
        const list = ref([1,2,3,4,5]);
        const addItem = () => {
            let value = Math.floor(Math.random() * 100);
            let index = Math.floor(Math.random() * list.value.length);
            list.value.splice(index, 0, value);
        }
        const removeItem = (index) => {
            list.value.splice(index, 1)
        }
    </script>
    <style scoped>
        .list-enter-from, .list-leave-to {
            opacity: 0;
        }
        .list-enter-active, .list-leave-active {
            transition: all 1s;
        }
        .list-leave-active {
            position: absolute;
        }
        .list-move {
            transition: all 1s;
        }
    </style>

53. SHALLOWREF
    - shallowRef is like ref, but it only tracks the reactivity at the .value level. Nested properties inside it is not reactive.
    - It is useful when you dont want deep reactivity
    - use this when the whole object changed
    - Example
    import { shallowRef } from 'vue'
    const state = shallowRef({ count: 0 })
    state.value.count++ // This will NOT trigger reactivity
    state.value = { count: 1 } // This will trigger reactivity  

54. TRIGGERREF
    - triggerRef is used to manually trigger reactivity for a ref or shallowRef.
    - You muted a value of a shallowRef, but since the nested properties are not reactive, the change will not be detected by Vue.
    - In such cases, we can use triggerRef to manually notify Vue that the value has changed and it should re-render any components that depend on that ref.
    - Example
    import { shallowRef, triggerRef } from 'vue'
    const state = shallowRef({ count: 0 })
    state.value.count++ // This will NOT trigger reactivity
    triggerRef(state) // Manually trigger reactivity

55. SHALLOWREACTIVE
    - Only top level properties are made reactive. Nested objects are not reactive.
    - It is useful when you want to avoid deep reactivity for performance reasons.
    - Example
    import { shallowReactive } from 'vue'
    const state = shallowReactive({ user: { name: 'John', age: 30 } })
    state.user.name = 'Jane' // This will NOT trigger reactivity
    state.user = { name: 'Jane', age: 30 } // This will trigger reactivity

56. KEEP ALIVE
    - It is used to cache the component instance when switching between components.
    - It is useful when we want to preserve the state of a component when it is not being displayed.
    - We can wrap the component we want to cache with the `<keep-alive>` component.
    - Normally when components are rendered onMounted will called and when we switch to another component, the previous component will be unmounted and its state will be lost.
    - When we use `<keep-alive>`, the component will be cached and its state will be preserved when we switch to another component.
    - The cached component will not be destroyed, it will be kept in memory and when we switch back to the component, it will be re-rendered with its previous state.
    - We can use the `activated` and `deactivated` lifecycle hooks to perform actions when the component is activated or deactivated.
    - We can use the `include` and `exclude` props to specify which components should be cached or not.
    - We can also use the `max` prop to limit the number of cached components.
        - include: A comma-separated string or a RegExp pattern to specify which components should be cached.
        - exclude: A comma-separated string or a RegExp pattern to specify which components should not be cached.
        - max: A number to limit the maximum number of cached components. When the limit is reached, the least recently used component will be removed from the cache.
    - Example
    <template>
        <button @click="currentComponent = 'ComponentA'">Show Component A</button>
        <button @click="currentComponent = 'ComponentB'">Show Component B</button>
        <keep-alive include="ComponentA">
            <component :is="currentComponent" />
        </keep-alive>
    </template>
    <script setup>
        import { ref } from 'vue'
        import ComponentA from './ComponentA.vue'
        import ComponentB from './ComponentB.vue'
        const currentComponent = ref('ComponentA')
    </script>

57. TELEPORT
    - Used to render a component or element somewhere else in the DOM outside of the current component hierarchy.
    - Useful for modals, tooltips, dropdowns, or any UI element that needs to be rendered outside of its parent component.

58. FRAGMENTS
    - Vue 3 supports fragments, which allows components to have multiple root elements.
    - This means we can return multiple elements from a component without having to wrap them in a single parent element.
    - Example
    <template>
        <h1>Title</h1>
        <p>This is a paragraph.</p>
    </template>
    <script setup>
    </script>

59. VUE-ROUTER 
    - Vue Router is the official router for Vue.js, it allows us to create single-page applications with multiple views and navigation.
    - We can define routes in a separate file and import them into our main application file.
    - We can use the `<router-view>` component to render the matched component for the current route.
    - We can use the `<router-link>` component to create links to different routes.

60. USEROUTE | USEROUTER
    - useRoute is a composition API function that allows us to access the current route object in a component.
    - It returns a reactive object that contains information about the current route, such as the path, params, query, and meta.
    - We can use this information to conditionally render content or perform actions based on the current route.
    - Example
    <template>
        <div>
            <h1>Current Route: {{ route.path }}</h1>
            <p v-if="route.params.id">Route Param ID: {{ route.params.id }}</p>
            <p v-if="route.query.name">Query Name: {{ route.query.name }}</p>
        </div>
    </template>
    <script setup>
        import { useRoute } from 'vue-router'
        const route = useRoute()
    </script>

    - useRouter is a composition API function that allows us to access the router instance in a component.
    - It returns the router instance, which we can use to programmatically navigate to different routes or access router methods and properties.
    - Example
    <template>
        <div>
            <button @click="goHome">Go to Home</button>
            <button @click="goToUser(1)">Go to User 1</button>
        </div>
    </template>
    <script setup>
        import { useRouter } from 'vue-router'
        const router = useRouter()
        function goHome() {
            router.push({ name: 'Home' })
        }
        function goToUser(id) {
            router.push({ name: 'User', params: { id } })
        }
    </script>

61. DYNAMIC ROUTE MATCHING 
    - We can define dynamic routes in Vue Router by using a colon `:` followed by a parameter name in the route path.
    - This allows us to create routes that can match different values for the same path.
    - We can access the dynamic parameters in the component using the `useRoute` function or the `$route` object.
    - Example
    // router/index.js
        import User from '../views/User.vue'
        const routes = [
            {
                path: '/users/:id',
                name: 'User',
                component: () => import('../views/User.vue')
            }
        ]

62. ROUTE MATCHING
    - Vue Router uses a priority-based matching system to determine which route to render for a given URL.
    - Static routes (without dynamic segments) have the highest priority, followed by dynamic routes (with parameters), and finally wildcard routes (catch-all).
    - When multiple routes match a URL, the route with the highest priority will be selected.
    - /:id (dynamic) has higher priority than /* (wildcard)
    - /:name+ (dynamic with one or more segments) has higher priority than /:name* (dynamic with zero or more segments)

63. NESTED ROUTES
    - We can define nested routes in Vue Router by using the `children` property in the route configuration.
    - This allows us to create a parent-child relationship between routes, where the child routes are rendered inside the parent route's component.
    - We can use the `<router-view>` component inside the parent component to render the matched child route.
    - Example
    // router/index.js
        const routes = [
            {
                path: 'users',
                name: 'Users',
                component: () => import('../views/Users.vue'),
                children: [
                    {
                        path: ':id',
                        name: 'User',
                        component: User,
                    }
                ]
            }
        ]

64. NAMED ROUTES
    - We can assign a name to a route using the `name` property in the route configuration.
    - This allows us to reference the route by its name instead of its path when navigating or creating links.
    - Using named routes can make our code more readable and maintainable, especially when dealing with dynamic routes or complex route structures.
    - params|query can be passed when using named routes. with path we can only pass query.
    - By using Named Routes 
        - we can avoid hardcoding paths in our code, 
        - making it easier to update routes in the future without having to change multiple references throughout the application.

65. PROGRAMMATIC NAVIGATION 
    - We can programmatically navigate to different routes using the `router.push` or `router.replace` methods from the router instance.
    - We can access the router instance using the `useRouter` function in a component.
    - The `router.push` method adds a new entry to the browser's history stack, while the `router.replace` method replaces the current entry.
    - We can pass an object with the route name, params, and query to these methods for navigation.
    - Example
    <template>
        <div>
            <button @click="goHome">Go to Home</button>
            <button @click="goToUser(1)">Go to User 1</button>
        </div>
    </template>
    <script setup>
        import { useRouter } from 'vue-router'
        const router = useRouter()
        function goHome() {
            router.push({ name: 'Home' })
        }
        function goToUser(id) {
            router.push({ name: 'User', params: { id } })
        }
    </script>

66. ROUTER.PUSH VS ROUTER.REPLACE
    - `router.push` 
        - adds a new entry to the browser's history stack, allowing users to navigate back to the previous page using the browser's back button.
    - `router.replace` 
        - replaces the current entry in the browser's history stack, meaning that users cannot navigate back to the previous page using the back button.
    - We should use `router.push` when we want to allow users to navigate back to the previous page, and use `router.replace` when we want to prevent users from going back to the previous page.

67. ROUTER.GO
    - The `router.go` method allows us to navigate through the browser's history stack by a specified number of steps.
    - We can pass a positive or negative integer to the `router.go` method to move forward or backward in the history stack.
    - A value of `1` will move forward one step, while a value of `-1` will move back one step.
    - Example
    <template>
        <div>
            <button @click="goBack">Go Back</button>
            <button @click="goForward">Go Forward</button>
        </div>
    </template>
    <script setup>
        import { useRouter } from 'vue-router'
        const router = useRouter()
        function goBack() {
            router.go(-1) // Go back one step in history
        }
        function goForward() {
            router.go(1) // Go forward one step in history
        }
    </script>

68. NAMED VIEWS 
    - Named views allow us to render multiple components in different `<router-view>` outlets within the same route.
    - We can define named views in the route configuration using the `components` property, where each key represents a named view and its value is the corresponding component.
    - In the template, we can use multiple `<router-view>` components with the `name` attribute to specify which named view to render.
    - Example
    // router/index.js
        const routes = [
            {
                 path: '/', 
                components: {
                    default: Home,
                    left: LeftSidebar,
                    right: RightSidebar
                } 
            }
        ]
    // App.vue
        <template>
            <router-view name="left" /> <!-- Left sidebar view -->
            <router-view /> <!-- Default view -->
            <router-view name="right" /> <!-- Right sidebar view -->
        </template>

69. PASSING PROPS TO ROUTE COMPONENTS
    - We can pass props to route components using the `props` option in the route configuration.
    - The `props` option can be set to `true`, an object, or a function.
    - When set to `true`, the route params will be passed as props to the component.
    - When set to an object, the object properties will be passed as props to the component.
    - When set to a function, the function will receive the route object as an argument and should return an object containing the props to be passed to the component.
    - Example
    // router/index.js
        const routes = [
            {
                path: '/user/:id',
                name: 'User',
                component: User,
                props: true // Route params will be passed as props
            },
            {
                path: '/settings',
                name: 'Settings',
                component: Settings,
                props: { theme: 'dark' } // Static props
            },
            {
                path: '/search',
                name: 'Search',
                component: Search,
                props: (route) => ({ query: route.query.q }) // Dynamic props from query
            }
        ]

70. NAVIGATION GUARDS
    - Navigation guards provided by vue-router , are primarily used to guard navigation either by redirecting or canceling.
    - We can use navigation guards to perform actions before or after a route is entered or left.
    - There are three types of navigation guards: global guards, per-route guards, and in-component guards.

71. GLOBAL GUARDS
    - are defined on the router instance and apply to all routes.
        - beforeEach 
            - called before every navigation
            - we can perform actions like authentication checks, logging, or data fetching before allowing the navigation to proceed.
            - we can stop the navigation by not calling `next()`, redirect to a different route by calling `next({ name: 'RouteName' })`, or allow the navigation to proceed by calling `next()`.
        - afterEach 
            - called after every navigation
            - we can perform actions like logging or analytics after the navigation has completed.
            - it does not have a `next` function, as the navigation is already confirmed.
        
        router.beforeEach((to, from, next) => {
            // Perform some action before navigation
            if (to.meta.requiresAuth && !isAuthenticated()) {
                next({ name: 'Login' }) // Redirect to login if not authenticated
            } else {
                next() // Allow navigation
            }
        })
        router.afterEach((to, from) => {
            // Perform some action after navigation
            console.log(`Navigated to ${to.fullPath} from ${from.fullPath}`)
        })

72. PER-ROUTE GUARDS 
        - are defined in the route configuration and apply only to that specific route.
        - We can use `beforeEnter` to define per-route guards.  
        - we can perform actions like authentication checks, logging, or data fetching before allowing the navigation to proceed.
        - we can stop the navigation by not calling `next()`, redirect to a different route by calling `next({ name: 'RouteName' })`, or allow the navigation to proceed by
        - We can write multiple per-route guards for a single route by providing an array of functions to the `beforeEnter` property.
        - beforeEnter: [auth1, auth2]

        const routes = [
            {
                path: '/admin',
                name: 'Admin',
                component: Admin,
                beforeEnter: (to, from, next) => {
                    // Perform some action before entering the admin route
                    if (isAdmin()) {
                        next() // Allow navigation
                    } else {
                        next({ name: 'Home' }) // Redirect to home if not an admin
                    }
                }
            }
        ]
    
73. IN-COMPONENT GUARDS
    - are defined in the component itself and apply only when that component is active.
    - We have two in-component guards: `onBeforeRouteLeave` and `onBeforeRouteUpdate`.
    - `onBeforeRouteLeave` is called when the user is navigating away from the current component.
    - `onBeforeRouteUpdate` is called when the user is navigating to the same component but with different route parameters.

74. ONBEFOREROUTEUPDTAE
    - Example - In dynamic routes - only params change - to react to that params change - we can use onBeforeRouteUpdate

71. BEFORERESOLVE GUARD
    - The `beforeResolve` guard is a global navigation guard in Vue Router that is called right before the navigation is confirmed, 
        after all in-component guards and async route components are resolved.
    - It is useful for performing actions that need to happen after all other guards have been executed, such as fetching data or updating the page title.

72. PINIA
    - Centralized State Management: 
        - Pinia provides a centralized store for managing application state, 
            making it easier to share data between components and maintain a consistent state across the application.
    - Reactive State: 
        - Pinia uses Vue's reactivity system, allowing us to create reactive state that automatically updates the UI when the state changes.
    - Modular Architecture: 
        - Pinia allows us to create multiple stores, each responsible for a specific part of the application state. 
        - This modular approach makes it easier to organize and maintain the codebase.
    - We can create stores using the `defineStore` function from Pinia.
    - We can access the store in our components using the `useStore` function.
    - Pinia supports both options API and composition API, allowing us to choose the approach that best fits our needs.

73. ACCESSING/STORING PINIA STATE/GETTERS/ACTIONS IN COMPONENTS
    - We can access the Pinia store in our components using the `useStore` function.
    - We can directly access in templates using `store.property` or `store.method()`
    - Example
    <template>
        <div>
            <p>Count: {{ counter.count }}</p>
            <p>Double Count: {{ counter.doubleCount }}</p>
            <button @click="counter.increment()">Increment</button>
        </div>
    </template>
    <script setup>
        import { useCounterStore } from './stores/counter'
        const counter = useCounterStore()
    </script>

    - In <script setup>
        - Primitive refs loses reactivity if we destructure or accessing with . 
        <template>
            <div>
                <p>Count: {{ count }}</p>
                <p>Double Count: {{ doubleCount }}</p>
                <button @click="increment()">Increment</button>
            </div>
        </template>
        <script setup>
            import { useCounterStore } from './stores/counter'
            const { count, doubleCount, increment } = useCounterStore()
            OR
            const counterStore = useCounterStore();
            const count = counterStore.count;
            const doubleCount = counterStore.doubleCount;
            const increment = counterStore.increment;
        </script> 

        - We have to use COMPUTED or STORETOREFS to maintain reactivity
        <script setup>
            import { useCounterStore } from './stores/counter'
            import { storeToRefs } from 'pinia'
            const counterStore = useCounterStore();
            const { count, doubleCount } = storeToRefs(counterStore);
            const { increment } = counterStore;
        </script> 
        OR
        <script setup>
            import { useCounterStore } from './stores/counter'
            import { computed } from 'vue'
            const counterStore = useCounterStore();
            const count = computed(() => counterStore.count);
            const doubleCount = computed(() => counterStore.doubleCount);
            const increment = counterStore.increment;
        </script>   

74. STORETOREFS
    - The `storeToRefs` function from Pinia is used to convert the properties of a Pinia store into reactive references.
    - This is particularly useful when we want to destructure the store properties while maintaining their reactivity.
    - Example
    <template>
        <div>
            <p>Count: {{ count }}</p>
            <p>Double Count: {{ doubleCount }}</p>
            <button @click="increment()">Increment</button>
        </div>
    </template>
    <script setup>
        import { useCounterStore } from './stores/counter'
        import { storeToRefs } from 'pinia'
        const counterStore = useCounterStore();
        const { count, doubleCount } = storeToRefs(counterStore);
        const { increment } = counterStore;
    </script>

    - When to use storeToRefs

        - You want to destructure state that‚Äôs a primitive ref (e.g. count = ref(1)) without losing reactivity.
        - You want to destructure getters (which are computed properties) without losing reactivity.

    Because in <script setup>, destructuring primitive refs or getters directly causes Vue‚Äôs auto-unwrapping to break reactivity.

    - When not necessary

        - For complex refs (arrays or objects like your notes), destructuring usually keeps reactivity without storeToRefs.
        - For actions (functions), destructuring is safe ‚Äî they don‚Äôt lose reactivity.

75. $PATCH
    - The `$patch` method in Pinia is used to update the state of a store in a more efficient way.
    - It allows us to update multiple properties of the state at once, without having to trigger multiple re-renders.
    - We can pass an object with the properties we want to update, or a function that receives the current state and returns the updated state.
    - Example
    // Using an object
    counterStore.$patch({
        count: store.count + 1,
        name: 'New Name'
    })
    // Using a function
    counterStore.$patch(state => {
        state.count += 1;
        state.name = 'New Name';
    })

76. $RESET 
    - The `$reset` method in Pinia is used to reset the state of a store to its initial state.
    - This can be useful when we want to clear the state of a store, for example, when logging out a user or resetting a form.
    - Example
    counterStore.$reset() // Resets the store state to its initial state
    - Note : $reset only available in Options API stores, not in setup stores. For setup stores we can create our own reset action.

77. $SUBSCRIBE
    - The `$subscribe` method in Pinia is used to listen for changes in the store's state.
    - It allows us to execute a callback function whenever the state of the store changes.
    - We can use this to perform side effects or trigger actions based on state changes.
    - Example
    const unsubscribe = counterStore.$subscribe((mutation, state) => {
        console.log('Mutation:', mutation)
        console.log('New State:', state)
    })
    // To stop listening for changes, we can call the unsubscribe function
    unsubscribe()

78. GETTERS IN PINIA COMPOSITION API STORE
    - Getters in Pinia are similar to computed properties in Vue.
    - They allow us to define derived state based on the store's state.

79. CSR - CLIENT SIDE RENDERING - VUE 3
    - The entire application is rendered on the client(browser) using JavaScript.
    - When user requests a page, the server sends a minimal HTML file with a script tag that loads the Vue application.
    - Then browser downloads the Javascript files, execute them and builds the UI.
    - Pros
        - Faster server response time since server only sends minimal HTML.
        - Cheaper server load as server does not have to render the entire page.
        - Better interactivity as the entire application is loaded on the client.
    - Cons
        - Slower initial load time as browser has to download and execute JavaScript files before rendering the UI.
        - Poor SEO as search engines may have difficulty indexing JavaScript-rendered content.
        - Not suitable for users with slow internet connections or older devices.

80. SSR - SERVER SIDE RENDERING - VUE 3
    - The application is rendered on the server and the fully rendered HTML is sent to the client.
    - When user requests a page, the server renders the Vue application and sends the fully rendered HTML to the browser.
    - Then browser downloads the Javascript files and hydrates the application, making it interactive.
    - Pros
        - Faster initial load time as the fully rendered HTML is sent to the browser.
        - Better SEO as search engines can easily index the fully rendered HTML content.
        - Suitable for users with slow internet connections or older devices.
    - Cons
        - Slower server response time as server has to render the entire page.
        - More expensive server load as server has to render the entire page for each request.
        - Less interactivity as the initial HTML is static and requires hydration to become interactive.

81. HYDRATION
    - Hydration is the process of attaching event listeners and making the server-rendered HTML interactive
    - When the server sends the fully rendered HTML to the browser, it is static and does not have any event listeners attached to it.
    - The browser downloads the JavaScript files and executes them, which attaches the event listeners to the existing HTML and makes it interactive.
    - Hydration is an important step in SSR as it allows the application to become fully functional on the client side.

82. HYDRATION WARNINGS 
    - In CSR also we can get hydration warnings due to below reasons
        - Invalid HTML structure - because browser auto corrects the invalid HTML in virtual DOM then compared with actual DOM it gives warning.
        - Vue‚Äôs virtual DOM and actual DOM differ for any reason.

83. FCP && LCP && CLS 
    - FCP - First Contentful Paint 
        - Time taken to render the first piece of content (text, image, SVG, etc.) on the screen.
        - Gives the user immediate feedback that something is happening.
        - How to improve:
            - Optimize server response time (faster backend or SSR).
            - Reduce render-blocking CSS and JavaScript
            - Inline critical CSS
            - Preload important fonts.
    
    - LCP - Largest Contentful Paint 
        - Time taken to render the largest visible content element
       - How to improve:
            - Optimize images (resize, compress, WebP).
            - Use a CDN for faster asset delivery.
            - Minimize main-thread work (heavy JS computations).
            - Consider SSR or pre-rendering for critical content.
    
    - CLS - Cumulative Layout Shift 
        - Measures visual stability ‚Äî how much the layout shifts unexpectedly during page load. 
        - Layout shifts frustrate users and can lead to accidental clicks.
        - How to improve:
            - Always include size attributes on images and videos.
            - Avoid inserting content above existing content (e.g., ads, banners).
            - Use CSS transform animations instead of properties that trigger layout changes.
            - Reserve space for dynamic content (e.g., ads, embeds).

    - We can use tools like Lighthouse or PageSpeed Insights to measure these metrics and identify areas for improvement.

84. PWA - PROGRESSIVE WEB APPS
    - Progressive Web Apps (PWAs) are web applications that use modern web capabilities to deliver an app-like experience to users.
    - PWAs can be installed on the user's device, work offline, and provide a fast and reliable experience.
    - We can use the Vue CLI PWA plugin to easily add PWA features to our Vue applications.
    - The plugin generates a service worker, manifest file, and other necessary files for a PWA.
    - We can customize the PWA settings in the `vue.config.js` file.

85. SEMANTIC HTML && ARIA ATTRIBUTES
    - HTML elements that have the meaning about their role in the web page.
    - Using semantic HTML improves accessibility, SEO, and maintainability of the code.
    - Examples of semantic HTML elements:
        - `<header>`: Represents the header of a section or page.
        - `<nav>`: Represents a section of navigation links.
        - `<main>`: Represents the main content of a document.
        - `<article>`: Represents a self-contained piece of content.
        - `<section>`: Represents a thematic grouping of content.
        - `<aside>`: Represents content that is tangentially related to the main content.
        - `<footer>`: Represents the footer of a section or page.
        - `<button>`: Represents a clickable button.
        - `<form>`: Represents a form for user input.
        - `<label>`: Represents a label for an input element.
        - `<input>`: Represents an input field.
    
    - ARIA (Accessible Rich Internet Applications) attributes are used to enhance the accessibility of web applications.
        - They provide additional information about the roles, states, and properties of elements.
        - Examples of ARIA attributes:
            - `role`: Defines the role of an element (e.g., `button`, `navigation`, `main`).
            - `aria-label`: Provides an accessible label for an element.
            - `aria-labelledby`: References another element that provides the label for the current element.
            - `aria-hidden`: Indicates whether an element is visible or hidden to assistive technologies.
            - `aria-expanded`: Indicates whether a collapsible element is expanded or collapsed.
            - `aria-controls`: Identifies the element that is controlled by the current element (e.g., a button that toggles a menu).
86. TABINDEX
    - in HTML some elements are focusable by default like links, buttons, form elements.
    - But some elements are not focusable by default like div, span, p etc.
    - We can make any element focusable by adding the `tabindex` attribute to it.
    - tabindex="0" makes the element focusable and includes it in the natural tab order
    - tabindex="-1" makes the element focusable but excludes it from the natural tab order
    - tabindex="positive number" makes the element focusable and includes it in the tab order before elements with tabindex="0"
    - We should use tabindex sparingly and only when necessary, as it can affect the natural tab order and accessibility of the page.
    - Example
    <div tabindex="0">Focusable Div</div>
    <div tabindex="-1">Focusable Div but not in tab order</div>
    <div tabindex="1">Focusable Div with higher priority in tab order</div>

87. ACCESSABILITY
    - Making resources and services usable by everyone regardless of their disabilities.
    - Important for inclusivity, legal compliance, and better user experience.
    - Best practices:
        - Use semantic HTML elements (e.g., `<button>`, `<nav>`, `<header>`, `<main>`, `<footer>`).
        - Provide alternative text for images using the `alt` attribute.
        - Ensure all interactive elements are focusable and operable via keyboard.
        - Use meaningful link text that describes the destination or action.
        - Implement skip links to allow users to bypass repetitive content.
        - Dont do outline none and use for id to labels
        - Ensure sufficient color contrast between text and background.
        - Make interactive elements (buttons, links) keyboard accessible.
        - Use ARIA (Accessible Rich Internet Applications) attributes to enhance accessibility.
        - Test with screen readers and other assistive technologies.
    - Tools:
        - axe
        - Lighthouse

88. SUSPENSE
    - Used to handle async components and provide a fallback UI while waiting for the async component to load.
    - We can wrap the async component with the `<Suspense>` component and provide a fallback slot.
    - Example
    <template>
        <Suspense>
            <template #default>
                <AsyncComponent />
            </template>
            <template #fallback>
                <div>Loading...</div>
            </template>
        </Suspense>
    </template>
    <script setup>
        import { defineAsyncComponent } from 'vue'
        const AsyncComponent = defineAsyncComponent(() => import('./AsyncComponent.vue'))
    </script>

89. HOW TO REDUCE BUNDLE SIZE IN VUE 3
    - Use Vue CLI or Vite for project setup, as they come with built-in optimizations.
    - Use dynamic imports and code splitting to load only the necessary code for each route or component.
    - Remove unused dependencies and libraries from the project.
    - Use tree-shaking to eliminate unused code from the final bundle.
    - Minify and compress the JavaScript and CSS files using tools like Terser and CSSNano.
    - Optimize images by compressing them and using modern formats like WebP.
    - Use a CDN to serve static assets, which can reduce the load on the server and improve performance.
    - Analyze the bundle size using tools like Webpack Bundle Analyzer or Rollup Plugin Visualizer to identify large dependencies and optimize them.

90. HOW TO DEBUG UNNECESSARY RE-RENDER IN VUE 3
    - Why re-render happens
        - Reactive data changes
        - Props changes
        - Parent component re-renders
        - Key attribute changes in v-for
        - Reactive object used inline
    - How to debug
        - Use Vue Devtools to inspect the component tree and see which components are re-rendering.
        - Check the reactive data and props used in the component to see if they are changing unnecessarily.
        - Use the `console.log` statement in the `setup` function or lifecycle hooks to track when the component is re-rendering.
        - Use the `watch` function to monitor specific reactive data or props and see if they are changing unexpectedly.
        - Check for any parent components that may be re-rendering and causing the child component to re-render as well.
        - Ensure that the `key` attribute in `v-for` loops is unique and stable to prevent unnecessary re-renders.
        - Avoid using reactive objects or arrays inline in the template, as this can cause unnecessary re-renders.
    - How to solve
        - Avoid creating new objects or arrays inline in the template.
        - Use `computed` properties to derive values from reactive data instead of using methods in the template.
        - Use v-memo to memoize the component and prevent unnecessary re-renders.
        - Split components into smaller, more focused components to reduce the scope of re-renders.
        - Avoid inline functions in the template, as they create new function instances on each render.

91. ATTACKS 
    - XSS (Cross-Site Scripting)
        - An attacker injects malicious scripts into a trusted website, which are then executed in the context of the user's browser.
        - Prevention:
            - Always sanitize and validate user input.
            - Use Vue's built-in escaping mechanisms (e.g., `{{ }}`) to prevent injection attacks.
            - Avoid using `v-html` unless absolutely necessary, and sanitize any HTML content before rendering it.

92. NEXTTICK

    What it is:
        - nextTick tells Vue: ‚ÄúWait until the page (DOM) is updated, then run my code.‚Äù
        - runs the code after the DOM has been updated.

    Why we use it:
        When you change a reactive value, Vue doesn‚Äôt update the page right away. It waits and updates everything together (for speed).
        If you need the new DOM (for example: measure size, scroll, or focus), you must wait until Vue is done. nextTick lets you do that.

        <template>
            <div>
                <p ref="messageRef">{{ message }}</p>
                <button @click="updateMessage">Update Message</button>
            </div>
        </template>

        <script setup>
            import { ref, nextTick } from 'vue'

            const message = ref('Hello, World!')
            const messageRef = ref(null)

            function updateMessage() {
                message.value = 'Hello, Vue 3!'

                // Wait for Vue to update the DOM
                nextTick(() => {
                    console.log('Message width:', messageRef.value.offsetWidth)
                })
            }
        </script>














